"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[555],{3114:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>f,frontMatter:()=>a,metadata:()=>l,toc:()=>h});var s=i(5893),r=i(1151),t=i(4214);const o="// ignore_for_file: avoid_print, unused_local_variable, unused_element\n\nimport 'dart:io';\nimport 'dart:math';\n\nimport 'package:async/async.dart';\nimport 'package:ribs_core/ribs_core.dart';\n\nFuture<void> snippet1() async {\n  /// io-1\n\n  final rng = Future(() => Random.secure().nextInt(1000));\n\n  await rng.then((x) => rng.then((y) => print('x: $x / y: $y')));\n\n  /// io-1\n}\n\nFuture<void> snippet2() async {\n  /// io-2\n\n  // Substitute the definition of fut with it's expression\n  // x and y are different! (probably)\n  await Future(() => Random.secure().nextInt(1000)).then((x) =>\n      Future(() => Random.secure().nextInt(1000))\n          .then((y) => print('x: $x / y: $y')));\n\n  /// io-2\n}\n\nFuture<void> snippet3() async {\n  /// io-3\n\n  final rng = IO.delay(() => Random.secure().nextInt(1000));\n\n  // x and y are different! (probably)\n  await rng\n      .flatMap((x) => rng.flatMap((y) => IO.println('x: $x / y: $y')))\n      .unsafeRunToFuture();\n\n  /// io-3\n}\n\nFuture<void> asyncSnippet1() async {\n  /// io-async-1\n\n  IO<A> futureToIO<A>(Function0<Future<A>> fut) {\n    IO.async_<A>((cb) {\n      fut().then(\n        (a) => cb(Right(a)),\n        onError: (Object err, StackTrace st) => cb(Left(IOError(err, st))),\n      );\n    });\n\n    throw UnimplementedError();\n  }\n\n  /// io-async-1\n}\n\nFuture<void> errorHandlingSnippet1() async {\n  /// error-handling-1\n\n  // composable handler using handleError\n  final ioA = IO.delay(() => 90 / 0).handleError((ioError) => 0);\n  final ioB = IO\n      .delay(() => 90 / 0)\n      .handleErrorWith((ioError) => IO.pure(double.infinity));\n\n  IO<double> safeDiv(int a, int b) => IO.defer(() {\n        if (b != 0) {\n          return IO.pure(a / b);\n        } else {\n          return IO.raiseError(IOError('cannot divide by 0!'));\n        }\n      });\n\n  /// error-handling-1\n}\n\nvoid safeResourcesSnippet1() {\n  /// safe-resources-1\n  final sink = File('path/to/file').openWrite();\n\n  try {\n    // use sink...\n  } catch (e) {\n    // catch error\n  } finally {\n    sink.close();\n  }\n\n  /// safe-resources-1\n}\n\nvoid safeResourcesSnippet2() {\n  /// safe-resources-2\n\n  final sink = IO.delay(() => File('path/to/file')).map((f) => f.openWrite());\n\n  // bracket *ensures* that the sink is closed\n  final program = sink.bracket(\n    (sink) => IO.exec(() => sink.writeAll(['Hello', 'World'])),\n    (sink) => IO.exec(() => sink.close()),\n  );\n\n  /// safe-resources-2\n}\n\nFuture<void> conversionsSnippet() async {\n  /// conversions-1\n\n  IO.fromOption(const Some(42), () => Exception('raiseError: none'));\n\n  IO.fromEither(Either.right(42));\n\n  IO.fromFuture(IO.delay(() => Future(() => 42)));\n\n  IO.fromCancelableOperation(IO.delay(\n    () => CancelableOperation.fromFuture(\n      Future(() => 32),\n      onCancel: () => print('canceled!'),\n    ),\n  ));\n\n  /// conversions-1\n\n  /// conversions-bad-future\n\n  final fut = Future(() => print('bad'));\n\n  // Too late! Future is already running!\n  final ioBad = IO.fromFuture(IO.pure(fut));\n\n  // IO.pure parameter is not lazy so it's evaluated immediately!\n  final ioAlsoBad = IO.fromFuture(IO.pure(Future(() => print('also bad'))));\n\n  // Here we preserve laziness so that ioGood is referentially transparent\n  final ioGood = IO.fromFuture(IO.delay(() => Future(() => print('good'))));\n\n  /// conversions-bad-future\n}\n\nFuture<void> cancelationSnippet() async {\n  /// cancelation-1\n  int count = 0;\n\n  // Our IO program\n  final io = IO\n      .pure(42)\n      .delayBy(const Duration(seconds: 10))\n      .onCancel(IO.exec(() => count += 1))\n      .onCancel(IO.exec(() => count += 2))\n      .onCancel(IO.exec(() => count += 3));\n\n  // .start() kicks off the IO execution and gives us a handle to that\n  // execution in the form of an IOFiber\n  final fiber = await io.start().unsafeRunToFuture();\n\n  // We immediately cancel the IO\n  fiber.cancel().unsafeRunAndForget();\n\n  // .join() will wait for the fiber to finish\n  // In this case, that's immediate since we've canceled the IO above\n  final outcome = await fiber.join().unsafeRunToFuture();\n\n  // Show the Outcome of the IO as well as confirmation that our `onCancel`\n  // handlers have been called since the IO was canceled\n  print('Outcome: $outcome | count: $count'); // Outcome: Canceled | count: 6\n  /// cancelation-1\n}\n",a={sidebar_position:1},c="IO",l={id:"core/effect/io",title:"IO",description:"IO is one of the most useful types in Ribs because it enables us to control",source:"@site/docs/core/effect/io.mdx",sourceDirName:"core/effect",slug:"/core/effect/io",permalink:"/ribs/docs/core/effect/io",draft:!1,unlisted:!1,editUrl:"https://github.com/cranst0n/ribs/edit/main/website/docs/core/effect/io.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Collections",permalink:"/ribs/docs/core/collections"},next:{title:"Resource",permalink:"/ribs/docs/core/effect/resource"}},d={},h=[{value:"Motivation",id:"motivation",level:2},{value:"Asynchronous Execution",id:"asynchronous-execution",level:2},{value:"IO.pure",id:"iopure",level:3},{value:"IO.delay",id:"iodelay",level:3},{value:"IO.async",id:"ioasync",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Safe Resource Handling",id:"safe-resource-handling",level:2},{value:"Conversions",id:"conversions",level:2},{value:"Cancelation",id:"cancelation",level:2},{value:"&#39;Unsafe&#39; Operations",id:"unsafe-operations",level:2}];function u(e){const n=Object.assign({h1:"h1",p:"p",code:"code",admonition:"admonition",a:"a",h2:"h2",em:"em",strong:"strong",ul:"ul",li:"li",h3:"h3"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"io",children:"IO"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IO"})," is one of the most useful types in Ribs because it enables us to control\nside effects and make it easier to write purely functional programs."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["If you're familiar with the ",(0,s.jsx)(n.code,{children:"IO"})," type from ",(0,s.jsx)(n.a,{href:"https://typelevel.org/cats-effect/",children:"Cats Effect"}),",\nthen Ribs ",(0,s.jsx)(n.code,{children:"IO"})," should look very similar. In fact, Ribs ",(0,s.jsx)(n.code,{children:"IO"})," is a very close\nport from Scala to Dart! The API is designed to stay as close as possible to\nthe original implementation."]})}),"\n",(0,s.jsx)(n.p,{children:"IO"}),"\n",(0,s.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsxs)(n.p,{children:["While Darts ",(0,s.jsx)(n.code,{children:"Future"})," type has it's uses, it also suffers from issues that make\nit unsuitable for functional programming. Consider the following code:"]}),"\n",(0,s.jsx)(t.O,{language:"dart",snippet:o,section:"io-1"}),"\n",(0,s.jsxs)(n.p,{children:["If you run this code, you should notice that the value of ",(0,s.jsx)(n.code,{children:"x"})," and ",(0,s.jsx)(n.code,{children:"y"})," are\nalways the same! Can you see why this is problematic? Now consider this piece\nof code where we replace each reference to ",(0,s.jsx)(n.code,{children:"fut"})," with the expression that ",(0,s.jsx)(n.code,{children:"fut"}),"\nevaluated to:"]}),"\n",(0,s.jsx)(t.O,{language:"dart",snippet:o,section:"io-2"}),"\n",(0,s.jsxs)(n.p,{children:["When we do the substitution, the meaning of the program changes which leads us\nto the conclusion that ",(0,s.jsx)(n.code,{children:"Future"})," is not referentially transparent! That means\nthat it's insufficient for use in pure functions."]}),"\n",(0,s.jsxs)(n.p,{children:["Here is where ",(0,s.jsx)(n.code,{children:"IO"})," steps in. It provides lazy, pure capabilities that provide\ngreater control over execution and dealing with failure. Here's the same\nprogram from above, using ",(0,s.jsx)(n.code,{children:"IO"})," instead of ",(0,s.jsx)(n.code,{children:"Future"}),"."]}),"\n",(0,s.jsx)(t.O,{language:"dart",snippet:o,section:"io-3"}),"\n",(0,s.jsxs)(n.p,{children:["You'll notice there are some differences in the APIs between ",(0,s.jsx)(n.code,{children:"Future"})," and ",(0,s.jsx)(n.code,{children:"IO"}),"\nbut for the sake of this example, you can assume that ",(0,s.jsx)(n.code,{children:"flatMap"})," is equivalent\nto ",(0,s.jsx)(n.code,{children:"then"})," and ",(0,s.jsx)(n.code,{children:"IO.println"})," is equivalent to ",(0,s.jsx)(n.code,{children:"print"}),". If you squint hard enough,\nthis ",(0,s.jsx)(n.code,{children:"IO"})," version should look pretty similar to the original implementation\nwhere we defined ",(0,s.jsx)(n.code,{children:"rng"})," using ",(0,s.jsx)(n.code,{children:"Future"}),". ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"However"})}),", this piece of code is\npure and referentially transparent because of the way ",(0,s.jsx)(n.code,{children:"IO"})," is implemented!"]}),"\n",(0,s.jsxs)(n.p,{children:["Along with this small but important quality, ",(0,s.jsx)(n.code,{children:"IO"})," provides the following\nfeatures:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Asynchronous Execution"}),"\n",(0,s.jsx)(n.li,{children:"Error Handling"}),"\n",(0,s.jsx)(n.li,{children:"Safe Resource Handling"}),"\n",(0,s.jsx)(n.li,{children:"Cancelation"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"asynchronous-execution",children:"Asynchronous Execution"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IO"})," is able to describe both synchronous and asynchronous effects."]}),"\n",(0,s.jsx)(n.h3,{id:"iopure",children:"IO.pure"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IO.pure"})," accepts a value. This means that there is no laziness or delaying\nof effects. Any parameter is eagerly evaluated."]}),"\n",(0,s.jsx)(n.h3,{id:"iodelay",children:"IO.delay"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IO.delay"})," can be used for ",(0,s.jsx)(n.strong,{children:"synchronous"})," effects that can be evaluated\nimmediately once the ",(0,s.jsx)(n.code,{children:"IO"})," itself is evaluated (within the context of the\nIO run loop)."]}),"\n",(0,s.jsx)(n.h3,{id:"ioasync",children:"IO.async"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IO.async"})," and ",(0,s.jsx)(n.code,{children:"IO.async_"})," is used to describe ",(0,s.jsx)(n.strong,{children:"asynchronous"})," effects that require a\ncallback to be invoked to indicate completion and resume execution. Using ",(0,s.jsx)(n.code,{children:"async"}),", we\ncan write a function that will convert a ",(0,s.jsx)(n.strong,{children:"lazy"})," ",(0,s.jsx)(n.code,{children:"Future"})," into an ",(0,s.jsx)(n.code,{children:"IO"}),"."]}),"\n",(0,s.jsx)(t.O,{language:"dart",title:"IO.async_",snippet:o,section:"io-async-1"}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IO"})," already has this conversion for ",(0,s.jsx)(n.code,{children:"Future"})," included but the example\nillustrates one case where ",(0,s.jsx)(n.code,{children:"IO.async_"})," is useful."]})}),"\n",(0,s.jsxs)(n.p,{children:["The only difference between ",(0,s.jsx)(n.code,{children:"IO.async"})," and ",(0,s.jsx)(n.code,{children:"IO.async_"})," is that with ",(0,s.jsx)(n.code,{children:"IO.async"}),"\nyou can include a cancelation finalizer. Since ",(0,s.jsx)(n.code,{children:"Future"})," doesn't have a\nmechanism for cancelation (at least at the time of this writing), we can safely\nuse ",(0,s.jsx)(n.code,{children:"IO.async_"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["To see an example of using ",(0,s.jsx)(n.code,{children:"IO.async"}),", check out the implementation of ",(0,s.jsx)(n.code,{children:"IO.fromCancelableOperation"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsxs)(n.p,{children:["One of the first recommendations on the ",(0,s.jsx)(n.a,{href:"https://dart.dev/language/error-handling",children:"Dart Error Handling page"}),"\ndemonstrates using ",(0,s.jsx)(n.code,{children:"Exception"}),"s paired with ",(0,s.jsx)(n.code,{children:"try"}),"/",(0,s.jsx)(n.code,{children:"catch"}),"/",(0,s.jsx)(n.code,{children:"finally"})," to manage\nerrors in your programs. But it's alredy been established that throwing\nexceptions is a side-effect! This rules out using them in our pure FP programs."]}),"\n",(0,s.jsxs)(n.p,{children:["That begs the question on how we create and handle errors using ",(0,s.jsx)(n.code,{children:"IO"}),"."]}),"\n",(0,s.jsx)(t.O,{language:"dart",title:"Error Handling with IO",snippet:o,section:"error-handling-1"}),"\n",(0,s.jsx)(n.h2,{id:"safe-resource-handling",children:"Safe Resource Handling"}),"\n",(0,s.jsx)(n.p,{children:"Let's begin with a fairly typical resource pattern used in Dart program that\nwant's opens a file, writes some data and then wants to make sure the file\nresource is closed:"}),"\n",(0,s.jsx)(t.O,{language:"dart",title:"Resource Safety try/catch/finally",snippet:o,section:"safe-resources-1"}),"\n",(0,s.jsxs)(n.p,{children:["Now let's write an equivalent program using ",(0,s.jsx)(n.code,{children:"IO"}),":"]}),"\n",(0,s.jsx)(t.O,{language:"dart",title:"Resource Safety with IO",snippet:o,section:"safe-resources-2"}),"\n",(0,s.jsxs)(n.p,{children:["This version using ",(0,s.jsx)(n.code,{children:"IO"})," has all the resource safety guarentees of the ",(0,s.jsx)(n.code,{children:"try"}),"/",(0,s.jsx)(n.code,{children:"catch"})," version but\ndoesn't use ",(0,s.jsx)(n.code,{children:"Exception"}),"s to avoid side-effects."]}),"\n",(0,s.jsx)(n.h2,{id:"conversions",children:"Conversions"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IO"})," comes with a few helper functions to convert common FP types into an ",(0,s.jsx)(n.code,{children:"IO"}),"."]}),"\n",(0,s.jsx)(t.O,{language:"dart",title:"IO Conversions",snippet:o,section:"conversions-1"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"IO.fromOption"}),": Takes an ",(0,s.jsx)(n.code,{children:"Option"})," and will either return a pure\nsynchronous ",(0,s.jsx)(n.code,{children:"IO"})," in the case of ",(0,s.jsx)(n.code,{children:"Some"})," or raise an error in the case of ",(0,s.jsx)(n.code,{children:"None"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"IO.fromEither"}),": Returns a pure ",(0,s.jsx)(n.code,{children:"IO"})," if the ",(0,s.jsx)(n.code,{children:"Either"})," is ",(0,s.jsx)(n.code,{children:"Right"})," or if\n",(0,s.jsx)(n.code,{children:"Left"}),", will raise an error using the value of the ",(0,s.jsx)(n.code,{children:"Left"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"IO.fromFuture"}),": Since ",(0,s.jsx)(n.code,{children:"Future"})," is eagerly evaluated and memoized,\n",(0,s.jsx)(n.code,{children:"fromFuture"})," takes a parameter of type ",(0,s.jsx)(n.code,{children:"IO<Future>"})," to control the laziness\nand ensure referential transparency."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsxs)(n.p,{children:["Simply using ",(0,s.jsx)(n.code,{children:"IO"})," doesn't magically make the ",(0,s.jsx)(n.code,{children:"Future"})," parameter referentially transparent!\nYou must still take care on controlling the evaluation of the ",(0,s.jsx)(n.code,{children:"Future"}),"."]})}),"\n",(0,s.jsx)(t.O,{language:"dart",title:"IO.fromFuture",snippet:o,section:"conversions-bad-future"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"IO.fromCancelableOperation"}),": This behaves in the same way as\n",(0,s.jsx)(n.code,{children:"IO.fromFuture"})," but is able to take advantage of some of the advanced features\nof ",(0,s.jsx)(n.code,{children:"CancelableOperation"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"cancelation",children:"Cancelation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IO"})," also allows you to build cancelable operations."]}),"\n",(0,s.jsx)(t.O,{language:"dart",title:"IO Cancel Example",snippet:o,section:"cancelation-1"}),"\n",(0,s.jsxs)(n.p,{children:["This is obviously a contrived example but exhibits that you have a great deal\nof power controlling the execution of an ",(0,s.jsx)(n.code,{children:"IO"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Also note that an ",(0,s.jsx)(n.code,{children:"IO"})," can only be checked for cancelation at it's asynchronous\nboundaries. Types of asynchronous boundaries include:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"IO.sleep"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IO.cede"})," (or autoCede occurances)"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"IO.async"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"unsafe-operations",children:"'Unsafe' Operations"}),"\n",(0,s.jsxs)(n.p,{children:["There are a few functions on ",(0,s.jsx)(n.code,{children:"IO"})," prefixed with the word ",(0,s.jsx)(n.code,{children:"unsafe"}),". These are\nwhat you should be calling at the 'edge(s)' of your program. In a completely\npure program, you should only call an 'unsafe' function once, in the main\nmethod after you've built and described your program using IO."]}),"\n",(0,s.jsxs)(n.p,{children:["The reason these functions include the 'unsafe' keyword isn't because your\ncomputer will explode when they're called. They're unsafe because they are\nnot pure functions and will interpret your ",(0,s.jsx)(n.code,{children:"IO"})," and perform side effects.\n'Unsafe' is included because you should always take care before deciding\nto call these functions."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"unsafeRunAsync"}),": As the name indicates, this will evaluate the ",(0,s.jsx)(n.code,{children:"IO"}),"\nasynchronously, and the provided callback will be executed when it has\nfinished;"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"unsafeRunAndForget"}),": Same as ",(0,s.jsx)(n.code,{children:"unsafeRunAsync"})," but no callback is provided."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"unsafeRunToFuture"}),": Evaluates the ",(0,s.jsx)(n.code,{children:"IO"})," and returns a ",(0,s.jsx)(n.code,{children:"Future"})," that will\ncomplete with the value of the ",(0,s.jsx)(n.code,{children:"IO"})," or any error that is encountered during\nthe evaluation."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"unsafeRunToFutureOutcome"}),": Returns a ",(0,s.jsx)(n.code,{children:"Future"})," that will complete with\nthe ",(0,s.jsx)(n.code,{children:"Outcome"})," of the ",(0,s.jsx)(n.code,{children:"IO"}),", being one of 3 possible states:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The value itself (successful)"}),"\n",(0,s.jsx)(n.li,{children:"The error encountered (errored)"}),"\n",(0,s.jsxs)(n.li,{children:["Marker indicating the ",(0,s.jsx)(n.code,{children:"IO"})," was canceled before completing (canceled)"]}),"\n"]}),"\n"]}),"\n"]})]})}const f=function(e={}){const{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(u,e)})):u(e)}}}]);