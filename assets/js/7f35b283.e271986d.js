"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[664],{8208:(t,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>b,default:()=>f,frontMatter:()=>a,metadata:()=>c,toc:()=>d});var n=i(7462),r=(i(7294),i(3905)),o=i(4214);const s="// ignore_for_file: avoid_print\n\nimport 'dart:typed_data';\n\nimport 'package:ribs_binary/ribs_binary.dart';\n\n/// bitvector-1\n\n// Creating ByteVectors\nfinal bytesA = ByteVector.empty();\nfinal bytesB = ByteVector.fromList([0, 12, 32]);\nfinal bytesC = ByteVector.low(10); // 10 bytes with all bits set to 0\nfinal bytesD = ByteVector.high(10); // 10 bytes with all bits set to 1\nfinal bytesE = ByteVector(Uint8List(10));\n\n// Creating BitVectors\nfinal bitsA = BitVector.empty();\nfinal bitsB = BitVector.fromByteVector(bytesA);\nfinal bitsC = BitVector.low(8); // 10 bits all set to 0\nfinal bitsD = BitVector.high(8); // 10 bits all set to 1\n\n/// bitvector-1\n\nvoid snippet2() {\n  /// bitvector-2\n\n  final bits =\n      BitVector.bits([true, false, true, true, false, false, true, true]);\n\n  print(bits.toBinString()); // 10110011\n  print('0x${bits.toHexString()}'); // 0xb3\n\n  bits.concat(bits); // combine 2 BitVectors\n  bits.drop(6); // drop the first 6 bits\n  bits.get(7); // get 7th bit\n  bits.clear(3); // set bit at index 3 to 0\n  bits.set(3); // set bit at index 3 to 1\n\n  /// bitvector-2\n}\n",a={sidebar_position:1},b="BitVector",c={unversionedId:"binary/bit-vector",id:"binary/bit-vector",title:"BitVector",description:"Ribs binary provides 2 specialized data types for working with binary data:",source:"@site/docs/binary/bit-vector.mdx",sourceDirName:"binary",slug:"/binary/bit-vector",permalink:"/ribs/docs/binary/bit-vector",draft:!1,editUrl:"https://github.com/cranst0n/ribs/edit/main/website/docs/binary/bit-vector.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Streaming",permalink:"/ribs/docs/json/streaming"},next:{title:"Encoding and Decoding",permalink:"/ribs/docs/binary/encoding-and-decoding"}},l={},d=[],p={toc:d},y="wrapper";function f(t){let{components:e,...i}=t;return(0,r.kt)(y,(0,n.Z)({},p,i,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"bitvector"},"BitVector"),(0,r.kt)("p",null,"Ribs binary provides 2 specialized data types for working with binary data:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ByteVector"),": Indexed collection of bytes built on top of ",(0,r.kt)("inlineCode",{parentName:"li"},"Uint8List")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"BitVector"),": Indexed collection of bits built on top of ",(0,r.kt)("inlineCode",{parentName:"li"},"ByteVector"))),(0,r.kt)("p",null,"The major difference between the 2 is what you're indexing into, bytes or bits."),(0,r.kt)(o.O,{language:"dart",title:"Creating Bit/Byte Vectors",snippet:s,section:"bitvector-1",mdxType:"CodeSnippet"}),(0,r.kt)("p",null,"Ribs also provides a rich API for manipulating these types:"),(0,r.kt)(o.O,{language:"dart",title:"BitVector API Sample",snippet:s,section:"bitvector-2",mdxType:"CodeSnippet"}))}f.isMDXComponent=!0}}]);