"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[440],{3390:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>m});var s=t(5893),r=t(1151),i=t(4214);const a="// ignore_for_file: unused_local_variable\n\nimport 'dart:io';\n\nimport 'package:ribs_core/ribs_core.dart';\nimport 'package:ribs_json/ribs_json.dart';\n\n/// streaming-1\n\nfinal class Event {\n  final String id;\n  final String type;\n  final Repo repo;\n\n  const Event(this.id, this.type, this.repo);\n\n  static final codec = Codec.product3(\n    'id'.as(Codec.string),\n    'type'.as(Codec.string),\n    'repo'.as(Repo.codec),\n    Event.new,\n    (evt) => (evt.id, evt.type, evt.repo),\n  );\n}\n\nfinal class Repo {\n  final int id;\n  final String name;\n\n  const Repo(this.id, this.name);\n\n  static final codec = Codec.product2(\n    'id'.as(Codec.integer),\n    'name'.as(Codec.string),\n    Repo.new,\n    (repo) => (repo.id, repo.name),\n  );\n}\n\n/// streaming-1\n\n/// streaming-2\n\n// Original stream of bytes\nfinal Stream<List<int>> byteStream =\n    File('path/to/big-array-file.json').openRead();\n\n// Use JsonTransformer to transform the bytes into individual JSON events\nfinal Stream<Json> jsonStream =\n    byteStream.transform(JsonTransformer.bytes(AsyncParserMode.unwrapArray));\n\n// Decode each Json stream element into an event, accounting for failure\nfinal Stream<Either<DecodingFailure, Event>> decodeStream =\n    jsonStream.map((json) => Event.codec.decode(json));\n\n// One step further...drop any decoding errors\nfinal Stream<Event> eventStream = decodeStream.expand((element) => element.fold(\n      (err) => <Event>[],\n      (event) => [event],\n    ));\n\n/// streaming-2\n\nFuture<void> snippet3() async {\n  /// streaming-3\n\n  final Socket sock = await Socket.connect('192.168.0.100', 12345);\n\n  final Stream<Json> jsonStream = sock\n      .map((event) => event.toList())\n      .transform(JsonTransformer.bytes(AsyncParserMode.valueStream));\n\n  /// streaming-3\n}\n",o={sidebar_position:4},l="Streaming",c={id:"json/streaming",title:"Streaming",description:"Ribs JSON also comes with an AsyncParser that supports emitting JSON elements",source:"@site/docs/json/streaming.mdx",sourceDirName:"json",slug:"/json/streaming",permalink:"/ribs/docs/json/streaming",draft:!1,unlisted:!1,editUrl:"https://github.com/cranst0n/ribs/edit/main/website/docs/json/streaming.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Encoding and Decoding",permalink:"/ribs/docs/json/encoding-and-decoding"},next:{title:"BitVector",permalink:"/ribs/docs/binary/bit-vector"}},d={},m=[{value:"Unwrap Array",id:"unwrap-array",level:2},{value:"Value Stream",id:"value-stream",level:2},{value:"Single Value",id:"single-value",level:2}];function p(e){const n=Object.assign({h1:"h1",p:"p",code:"code",h2:"h2",pre:"pre"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"streaming",children:"Streaming"}),"\n",(0,s.jsxs)(n.p,{children:["Ribs JSON also comes with an ",(0,s.jsx)(n.code,{children:"AsyncParser"})," that supports emitting JSON elements\nas they arrive in situations like reading bytes from a file or a streaming HTTP\nresponse."]}),"\n",(0,s.jsx)(n.h2,{id:"unwrap-array",children:"Unwrap Array"}),"\n",(0,s.jsxs)(n.p,{children:["The first mode of streaming Ribs supports is ",(0,s.jsx)(n.code,{children:"unwrapArray"}),", which expects the\nstreamed JSON to consist of a top level JSON array. The parser will then emit\nevents as each child element is completely received."]}),"\n",(0,s.jsx)(n.p,{children:"To illustrate, let's start with a basic setup with a couple domain models and\nJSON codecs defined for each:"}),"\n",(0,s.jsx)(i.O,{language:"dart",title:"Models",snippet:a,section:"streaming-1"}),"\n",(0,s.jsx)(n.p,{children:"Now consider that the incoming JSON, (whether it be from a file, a socket or\nan HTTP response), will take on the following structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'[\n    {\n        "id": "2489651045",\n        "type": "CreateEvent",\n        "repo": {\n            "id": 28688495,\n            "name": "petroav/6.828",\n            "url": "https://api.github.com/repos/petroav/6.828"\n        }\n    },\n    {\n        "id": "2489651051",\n        "type": "PushEvent",\n        "repo": {\n            "id": 28671719,\n            "name": "rspt/rspt-theme",\n            "url": "https://api.github.com/repos/rspt/rspt-theme"\n        }\n    },\n    //\n    //     Tens, hundreds, thousands of more events....\n    //\n    {\n        "id": "2489651591",\n        "type": "WatchEvent",\n        "repo": {\n            "id": 21289110,\n            "name": "vinta/awesome-python",\n            "url": "https://api.github.com/repos/vinta/awesome-python"\n        }\n    }\n]\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We can emit each of these individual ",(0,s.jsx)(n.code,{children:"Event"}),"s using the ",(0,s.jsx)(n.code,{children:"JsonTransformer"}),"\nin the Ribs Json library. Here's a simple example of how it's used:"]}),"\n",(0,s.jsx)(i.O,{language:"dart",title:"Unwrap Array Transformer",snippet:a,section:"streaming-2"}),"\n",(0,s.jsx)(n.h2,{id:"value-stream",children:"Value Stream"}),"\n",(0,s.jsxs)(n.p,{children:["In the case the stream contains multiple top-level JSON elements, you'll want\nto use ",(0,s.jsx)(n.code,{children:"AsyncParserMode.valueStream"})," when creating your ",(0,s.jsx)(n.code,{children:"JsonTransformer"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Consider the incoming JSON will look something like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'["Name", "Session", "Score", "Completed"]\n{"name": "Gilbert", "wins": [["straight", "7\u2663"], ["one pair", "10\u2665"]]}\n["Gilbert", "2013", 24, true]\n//\n//    tens, hundreds, thousands of other JSON elements...\n//\n{"name": "Deloise", "wins": [["three of a kind", "5\u2663"]]}\n["Deloise", "2012A", 19, true]\n'})}),"\n",(0,s.jsx)(n.p,{children:"We'll creating our transformer in exactly the same way, but change the mode\nthe parser will operate as:"}),"\n",(0,s.jsx)(i.O,{language:"dart",title:"Value Stream Transformer",snippet:a,section:"streaming-3"}),"\n",(0,s.jsx)(n.h2,{id:"single-value",children:"Single Value"}),"\n",(0,s.jsxs)(n.p,{children:["The last mode available expects a single top level JSON element and won't emit\nthe JSON event until it's entirely received. This effectively turns the\n",(0,s.jsx)(n.code,{children:"JsonTransformer"})," into a standard synchronous parser but could still be useful\nin some situations."]})]})}const h=function(e={}){const{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(p,e)})):p(e)}}}]);