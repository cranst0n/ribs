"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[937],{4838:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>h,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var i=t(5893),a=t(1151),s=t(4214);const r="import 'package:ribs_core/ribs_core.dart';\n\n// create-user-1\n\nfinal class User {\n  final String name;\n  final String alias;\n  final int age;\n\n  const User(this.name, this.alias, this.age);\n}\n\nOption<User> userOption(String name, String alias, int age) => (\n      Option.when(() => name.isEmpty, () => name),\n      Option.when(() => alias.isEmpty, () => alias),\n      Option.when(() => age >= 18, () => age),\n    ).mapN(User.new);\n\n// create-user-1\n\n// create-user-2\n\nfinal create1 = userOption('Jonathan', 'Jon', 21); // Some(User(...))\nfinal create2 = userOption('Jonathan', '', 32); // None()\nfinal create3 = userOption('', 'Jon', 55); // None()\n\n// create-user-2\n\n// create-user-3\n\nEither<String, User> userEither(String name, String alias, int age) {\n  if (name.isNotEmpty) {\n    if (alias.isNotEmpty) {\n      return Right(User(name, alias, age));\n    } else {\n      return const Left('Alias is required!');\n    }\n  } else {\n    return const Left('Name is required!');\n  }\n}\n\nfinal create4 = userEither('Jonathan', 'Jon', 21); // Right(Instance of 'User')\nfinal create5 = userEither('Jonathan', '', 32); // Left(Alias is required!)\nfinal create6 = userEither('', 'Jon', 55); // Left(Name is required!)\n\n// create-user-3\n\n// map-1\n\nconst myLeft = Left<int, String>(42);\nconst myRight = Right<int, String>('World');\n\nString greet(String str) => 'Hello $str!';\n\nfinal myLeft2 = myLeft.map(greet); // Left(42)\nfinal myRight2 = myRight.map(greet); // Right(Hello World!)\n\n// map-1\n\n// flatMap-1\n\nEither<String, User> validateName(User u) =>\n    Either.cond(() => u.name.isNotEmpty, () => u, () => 'User name is empty!');\n\nEither<String, User> validateAlias(User u) => Either.cond(\n    () => u.alias.isNotEmpty, () => u, () => 'User alias is empty!');\n\nEither<String, User> validateAge(User u) =>\n    Either.cond(() => u.age > 35, () => u, () => 'User is too young!');\n\nconst candidate = User('Harrison', 'Harry', 30);\n\nfinal validatedCandidate = validateName(candidate)\n    .flatMap(validateAlias)\n    .flatMap(validateAge); // Left(User is too young!)\n\n// flatMap-1\n\n// fold-1\n\nfinal foldLeft = const Left<bool, int>(false).fold(\n  (boolean) => 'bool value is: $boolean',\n  (integer) => 'int value is: $integer',\n);\n\n// fold-1\n",o={sidebar_position:3},h="Either",l={id:"core/either",title:"Either",description:"Either is type that represents the existence of one of two types. An instance",source:"@site/docs/core/either.mdx",sourceDirName:"core",slug:"/core/either",permalink:"/ribs/docs/core/either",draft:!1,unlisted:!1,editUrl:"https://github.com/cranst0n/ribs/edit/main/website/docs/core/either.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Option",permalink:"/ribs/docs/core/option"},next:{title:"Validated",permalink:"/ribs/docs/core/validated"}},c={},d=[{value:"Motivation",id:"motivation",level:2},{value:"Combinators",id:"combinators",level:2},{value:"map",id:"map",level:3},{value:"flatMap",id:"flatmap",level:3},{value:"fold",id:"fold",level:3}];function p(e){const n=Object.assign({h1:"h1",p:"p",code:"code",h2:"h2",strong:"strong",admonition:"admonition",h3:"h3",em:"em"},(0,a.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"either",children:"Either"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Either"})," is type that represents the existence of one of two types. An instance\nof ",(0,i.jsx)(n.code,{children:"Either"})," is an instance of ",(0,i.jsx)(n.code,{children:"Left"})," or ",(0,i.jsx)(n.code,{children:"Right"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,i.jsxs)(n.p,{children:["While ",(0,i.jsx)(n.code,{children:"Option"})," is a great weapon to have in our functional toolbelt, sometimes\nit isn't enough. Sometimes it makes sense to provide additional information\nwhen our functions don't follow the \"happy path\". For ",(0,i.jsx)(n.code,{children:"Option"}),"s, the happy\npath can be considered returning ",(0,i.jsx)(n.code,{children:"Some(...)"})," while the failure path would be\nreturning ",(0,i.jsx)(n.code,{children:"None"}),". But consider the example below:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"User Creation using Option",snippet:r,section:"create-user-1"}),"\n",(0,i.jsxs)(n.p,{children:["Reading the code, we can see that a new user requires a non-empty name ",(0,i.jsx)(n.strong,{children:"and"}),"\na non-empty alias. Let's see what happens when we try to create a few users:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",snippet:r,section:"create-user-2"}),"\n",(0,i.jsxs)(n.p,{children:["We can see that the function works as intended which is great but consider\nthe results returned in the failure case when the user's name and/or alias is\nempty. They're all ",(0,i.jsx)(n.code,{children:"None"}),". It would be much better if we could return a reason\nwhy the user couldn't be created right? So let's do better using the ",(0,i.jsx)(n.code,{children:"Either"}),"\ntype:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"User Creation using Either",snippet:r,section:"create-user-3"}),"\n",(0,i.jsxs)(n.p,{children:["Much better! We can now see ",(0,i.jsx)(n.strong,{children:"why"})," the function was unable to create the user\nin each instance. This would be great information to pass along to the user\nto help them navigate our application."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:['We said earlier that the "happy" path for ',(0,i.jsx)(n.code,{children:"Option"})," is ",(0,i.jsx)(n.code,{children:"Some"})," vs. the failure\npath of ",(0,i.jsx)(n.code,{children:"None"}),". So what is the happy/failure paths for ",(0,i.jsx)(n.code,{children:"Either"}),"? Looking at\nthe previous examples, it should become clear that the happy path is ",(0,i.jsx)(n.code,{children:"Right"}),"\nwhile the failure path is ",(0,i.jsx)(n.code,{children:"Left"}),". This is by convention so you could choose\nto ignore this, but be aware that many combinators in the Either API treat\nthe Right side as the happy path, leading to the statement that ",(0,i.jsx)(n.code,{children:"Either"}),' is\n"right biased".']})}),"\n",(0,i.jsx)(n.h2,{id:"combinators",children:"Combinators"}),"\n",(0,i.jsx)(n.h3,{id:"map",children:"map"}),"\n",(0,i.jsxs)(n.p,{children:["Much like ",(0,i.jsx)(n.code,{children:"Option"})," the ",(0,i.jsx)(n.code,{children:"map"})," method on ",(0,i.jsx)(n.code,{children:"Either"})," will apply a function to\nthe value, so long as the ",(0,i.jsx)(n.code,{children:"Either"})," is an instance of ",(0,i.jsx)(n.code,{children:"Right"}),":"]}),"\n",(0,i.jsx)(s.O,{language:"dart",snippet:r,section:"map-1"}),"\n",(0,i.jsx)(n.h3,{id:"flatmap",children:"flatMap"}),"\n",(0,i.jsxs)(n.p,{children:["Chaining functions that return ",(0,i.jsx)(n.code,{children:"Either"})," is simple using the ",(0,i.jsx)(n.code,{children:"Either.flatMap"}),"\nfunction:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",snippet:r,section:"flatMap-1"}),"\n",(0,i.jsx)(n.h3,{id:"fold",children:"fold"}),"\n",(0,i.jsxs)(n.p,{children:["Lastly, when you want to create a summary value from the ",(0,i.jsx)(n.code,{children:"Either"})," depending\non whether it's a ",(0,i.jsx)(n.code,{children:"Left"})," or ",(0,i.jsx)(n.code,{children:"Right"}),", the ",(0,i.jsx)(n.code,{children:"fold"})," method makes it easy:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",snippet:r,section:"fold-1"}),"\n",(0,i.jsxs)(n.p,{children:["As specified in the ",(0,i.jsx)(n.code,{children:"fold"})," function signature, each function provided\n",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"must"})})," return a value of the same type."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Either has a lot of other useful combinators to make using them easy\nand expressive! Check out the API to explore them."})})]})}const u=function(e={}){const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,i.jsx)(n,Object.assign({},e,{children:(0,i.jsx)(p,e)})):p(e)}}}]);