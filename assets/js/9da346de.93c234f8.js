"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[627],{6369:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>c,toc:()=>h});var i=t(5893),o=t(1151),s=t(4214);const a="import 'dart:math';\n\nimport 'package:ribs_core/ribs_core.dart';\n\n// naive\n\nint naiveMax(List<int> xs) {\n  if (xs.isEmpty) {\n    throw UnimplementedError('What do we do?');\n  } else {\n    return xs.reduce((maxSoFar, element) => max(maxSoFar, element));\n  }\n}\n\n// naive\n\n// better\n\nOption<int> betterMax(List<int> xs) {\n  if (xs.isEmpty) {\n    return const None();\n  } else {\n    return Some(xs.reduce((maxSoFar, element) => max(maxSoFar, element)));\n  }\n}\n\n// better\n\n// better-yet\n\nOption<int> betterYetMax(List<int> xs) =>\n    Option.when(() => xs.isNotEmpty, () => xs.reduce(max));\n\n// better-yet\n\n// combinators-1\n\nint? foo(String s) => throw UnimplementedError();\ndouble bar(int s) => throw UnimplementedError();\n\n// How can we pipe these 2 functions together to acheive this:\n// final result = bar(foo('string'));\n\n// combinators-1\n\n// combinators-2\n\n// How can we pipe these 2 functions together to acheive this:\nfinal resA = foo('string');\nfinal result = resA != null ? bar(resA!) : null;\n\n// combinators-2\n\n// combinators-3\n\nOption<int> fooOpt(String s) => throw UnimplementedError();\ndouble barOpt(int s) => throw UnimplementedError();\n\nfinal resultOpt = fooOpt('string').map((i) => barOpt(i));\n\n// combinators-3\n\n// flatmap-1\n\nOption<String> validate(String s) => Option.when(() => s.isNotEmpty, () => s);\nOption<String> firstName(String s) {\n  final parts = s.split(' ');\n  if (parts.length == 2) {\n    return Some(parts.first);\n  } else {\n    return const None();\n  }\n}\n\nfinal nameA = validate('John Doe').flatMap(firstName); // Some('John')\nfinal nameB = validate('Madonna').flatMap(firstName); // None\n\n// flatmap-1\n\n// mapN-1\n\nconst firstN = Some('Tommy');\nconst middleN = Some('Lee');\nconst lastN = Some('Jones');\n\n// Combine the 3 name parts into full name\nfinal fullName1 = firstN.flatMap(\n  (first) => middleN.flatMap(\n    (middle) => lastN.map(\n      (last) => '$first $middle $last',\n    ),\n  ),\n);\n\n// mapN-1\n\n// mapN-2\n\n// Combine the 3 name parts into full name using mapN\nfinal fullName2 = (firstN, middleN, lastN).mapN((f, m, l) => '$f $m $l');\n\n// mapN-2\n",r={sidebar_position:2},l="Option",c={id:"core/option",title:"Option",description:"Motivation",source:"@site/docs/core/option.mdx",sourceDirName:"core",slug:"/core/option",permalink:"/ribs/docs/core/option",draft:!1,unlisted:!1,editUrl:"https://github.com/cranst0n/ribs/edit/main/website/docs/core/option.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Functions",permalink:"/ribs/docs/core/functions"},next:{title:"Either",permalink:"/ribs/docs/core/either"}},d={},h=[{value:"Motivation",id:"motivation",level:2},{value:"Combinators",id:"combinators",level:2},{value:"map",id:"map",level:3},{value:"flatMap",id:"flatmap",level:3},{value:"mapN",id:"mapn",level:3}];function p(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"option",children:"Option"}),"\n",(0,i.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Option"})," type signifies the presence or absense of a value. In some\ncircumstances, a function won't be able to give a resulting value for every\ninput. These are called ",(0,i.jsx)(n.em,{children:"partial functions"})," (as opposed to ",(0,i.jsx)(n.em,{children:"total functions"}),")\nsince they are only defined for certain inputs. Let's have a look at an\nexample of a naively implemented partial function:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Our First Partial Function",snippet:a,section:"naive"}),"\n",(0,i.jsxs)(n.p,{children:["The intent is to find the maximum value in the provided ",(0,i.jsx)(n.code,{children:"List<int>"}),". But what\nhappens if the list is empty? In this example the function will ",(0,i.jsx)(n.code,{children:"throw"}),".\nExceptions are not an option when building purely functional programs.\nThey require that the context of caller be known at all times in order to\nreason about what the ultimate value of the function will be."]}),"\n",(0,i.jsxs)(n.p,{children:["Do we return 0? Do we return -99999? Either of\nthose result in an ambiguous result that the caller of the function will need\ninterpret. This violates one of the core tenets of functional programming:\n",(0,i.jsx)(n.strong,{children:"Local Reasoning"}),". The caller shouldn't need to interpret the value. The\n",(0,i.jsx)(n.strong,{children:"type"})," of the value should convey that on it's own!"]}),"\n",(0,i.jsxs)(n.p,{children:["So let's improve on the initial implementation of our function to use the\n",(0,i.jsx)(n.code,{children:"Option"})," type:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"An Improvement",snippet:a,section:"better"}),"\n",(0,i.jsx)(n.p,{children:"By changing the type that's returned, we've indicated to the user (and the compiler)\nthat this function may not be able to return a value. As a result, the\ndeveloper must account for either case."}),"\n",(0,i.jsxs)(n.p,{children:["Let's make this function even more readable. Here's a more elegant way to\ndefine our ",(0,i.jsx)(n.code,{children:"max"})," function even more concisely using the ",(0,i.jsx)(n.code,{children:"Option"})," API:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Using Option API",snippet:a,section:"better-yet"}),"\n",(0,i.jsx)(n.h2,{id:"combinators",children:"Combinators"}),"\n",(0,i.jsx)(n.h3,{id:"map",children:"map"}),"\n",(0,i.jsxs)(n.p,{children:["You may ask yourself why we would ever want to use ",(0,i.jsx)(n.code,{children:"Option"})," when Dart has\nnullable types. And while nullable types are a great addition to the language,\nthey aren't as powerful and expressive as ",(0,i.jsx)(n.code,{children:"Option"}),". On top of this, there are\nstill gaps in the nullable type system that make ",(0,i.jsx)(n.code,{children:"Option<int>"})," preferable to\n",(0,i.jsx)(n.code,{children:"int?"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's take the following example and see how ",(0,i.jsx)(n.code,{children:"Option"})," can make our code more\nreadable and composable."]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Contrived Nullable Functions",snippet:a,section:"combinators-1"}),"\n",(0,i.jsx)(n.p,{children:"We want to feed the output of the first function into the second function.\nBut using Dart's nullable types, this becomes verbose and more difficult to\ndecipher:"}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Composing Nullable Values",snippet:a,section:"combinators-2"}),"\n",(0,i.jsxs)(n.p,{children:["Compare that version with the null checking to this version using ",(0,i.jsx)(n.code,{children:"Option"}),":"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Composing Option Values",snippet:a,section:"combinators-3"}),"\n",(0,i.jsxs)(n.p,{children:["Now consider how this very small scenario would look like when you try to\ncompose the results from 3 functions together. Then 10 functions. The ",(0,i.jsx)(n.code,{children:"Option"}),"\nAPI shines in these cases because functions compose. On top of this simple\nexcersice, ",(0,i.jsx)(n.code,{children:"Option"})," has a number of additional combinators like ",(0,i.jsx)(n.code,{children:"map"}),", ",(0,i.jsx)(n.code,{children:"filter"}),"\nand others."]}),"\n",(0,i.jsx)(n.h3,{id:"flatmap",children:"flatMap"}),"\n",(0,i.jsxs)(n.p,{children:["Another common scenario arises when you want to feed one functions ",(0,i.jsx)(n.code,{children:"Option<A>"}),"\ninto another functions parameter:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Composing Option Values",snippet:a,section:"flatmap-1"}),"\n",(0,i.jsxs)(n.p,{children:["This example shows how you can chain functions that use ",(0,i.jsx)(n.code,{children:"Option"})," together to\ncreate readable code. Achieving this level of expressiveness using nullable types\nalone isn't possible."]}),"\n",(0,i.jsx)(n.h3,{id:"mapn",children:"mapN"}),"\n",(0,i.jsxs)(n.p,{children:["Our final scenario, but certainly not last you'll encounter in the wild arises\nwhen you have a few ",(0,i.jsx)(n.code,{children:"Option"})," values and want to combine them into something else.\nOur starting point looks like this:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Combining Option Values - Naive",snippet:a,section:"mapN-1"}),"\n",(0,i.jsxs)(n.p,{children:["While this strategy works, you can certainly make the argument that it's not\nparticularly readable. Because this is such a common scenario, ribs includes a\n",(0,i.jsx)(n.code,{children:"mapN"})," combinator that takes care of all the messy ",(0,i.jsx)(n.code,{children:"flatMap"})," and ",(0,i.jsx)(n.code,{children:"map"}),"-ing\nfor you:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Combining Option Values - Naive",snippet:a,section:"mapN-2"}),"\n",(0,i.jsxs)(n.p,{children:["By creating a tuple of your ",(0,i.jsx)(n.code,{children:"Option"})," values, you can then use ",(0,i.jsx)(n.code,{children:"mapN"})," as a\nshortcut to achieve what we're after. Note that the number of ",(0,i.jsx)(n.code,{children:"Option"}),"\nvalues you're combining (arity) doesn't matter. Ribs will handle tuples up to\nsize 22!"]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"mapN"})," isn't just used for combining ",(0,i.jsx)(n.code,{children:"Option"})," values. You'll find it used\nfor other data types as well including ",(0,i.jsx)(n.code,{children:"Either"}),", ",(0,i.jsx)(n.code,{children:"IO"})," and many more!"]})}),"\n",(0,i.jsxs)(n.p,{children:["This is hardly an exhautive list of the ",(0,i.jsx)(n.code,{children:"Option"})," combinators so be sure to\nexplore the full API."]})]})}function m(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);