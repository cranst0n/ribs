"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[933],{2138:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>t,metadata:()=>r,toc:()=>h});var s=i(5893),d=i(1151),c=i(4214);const o="// ignore_for_file: avoid_print\n\nimport 'package:ribs_binary/ribs_binary.dart';\nimport 'package:ribs_core/ribs_core.dart';\n\n// codecs-1\n\nfinal class Document {\n  final Header header;\n  final IList<Message> messages;\n\n  const Document(this.header, this.messages);\n}\n\nfinal class Header {\n  final double version;\n  final String comment;\n  final int numMessages;\n\n  const Header(this.version, this.comment, this.numMessages);\n}\n\nsealed class Message {}\n\nfinal class Info extends Message {\n  final String message;\n\n  Info(this.message);\n}\n\nfinal class Debug extends Message {\n  final int lineNumber;\n  final String message;\n\n  Debug(this.lineNumber, this.message);\n}\n\n// codecs-1\n\n// codecs-2\n\nfinal infoCodec =\n    Codec.utf16_32.xmap((str) => Info(str), (info) => info.message);\n\nfinal debugCodec = Codec.product2(\n  Codec.int32L, // 32-bit little endian int\n  Codec.ascii32, // ascii bytes with 32bit size prefix\n  Debug.new,\n  (dbg) => (dbg.lineNumber, dbg.message),\n);\n\n// codecs-2\n\n// codecs-3\n\nfinal messageCodec = Codec.discriminatedBy(\n  Codec.uint8, // encode identifier using an 8-bit integer\n  imap({\n    0: infoCodec, // instances of Info prefixed by ID 0\n    1: debugCodec, // instances of Debug prefixed by ID 1\n  }),\n);\n\n// codecs-3\n\n// codecs-4\n\nfinal documentCodec = Codec.product2(\n  headerCodec,\n  // ilist of Messages with 16-bit int prefix indicating # of elements\n  Codec.ilistOfN(Codec.int16, messageCodec),\n  Document.new,\n  (doc) => (doc.header, doc.messages),\n);\n\nfinal headerCodec = Codec.product3(\n  Codec.float32, // 32-bit floating point\n  Codec.utf8_32, // utf8 bytes with 32bit size prefix\n  Codec.int64, // 64-bit integer\n  (version, comment, numMessages) => Header(version, comment, numMessages),\n  (hdr) => (hdr.version, hdr.comment, hdr.numMessages),\n);\n\n// codecs-4\n\nvoid snippet5() {\n  // codecs-5\n  final doc = Document(\n      const Header(1.1, 'Top Secret', 3),\n      IList.fromDart([\n        Info('Hello!'),\n        Debug(123, 'breakpoint-1'),\n        Info('Goodbye!'),\n      ]));\n\n  // Encoding will give us an error or the successfully encoded BitVector\n  final Either<Err, BitVector> bits = documentCodec.encode(doc);\n\n  print(bits);\n  // Right(3f8ccccd00000050546f702053656372657400000000000000030003000000003048656c6c6f21017b00000000000060627265616b706f696e742d310000000040476f6f6462796521)\n\n  // Decoding will give us either an error if it failed or the DecodeResult\n  // A DecodeResult gives us the successfully decoded value and any remaining bits from the input\n  // ** Note the throw is included only for edification purposes. This is not a good idea in production code\n  final Either<Err, DecodeResult<Document>> decoded = documentCodec\n      .decode(bits.getOrElse(() => throw Exception('encode failed!')));\n\n  print(decoded);\n  // Right(DecodeResult(Instance of 'Document', ByteVector.empty))\n\n  // codecs-5\n}\n",t={sidebar_position:2},a="Encoding and Decoding",r={id:"binary/encoding-and-decoding",title:"Encoding and Decoding",description:"Much like Ribs JSON library, Ribs lets you define binary Codecs that make it",source:"@site/docs/binary/encoding-and-decoding.mdx",sourceDirName:"binary",slug:"/binary/encoding-and-decoding",permalink:"/ribs/docs/binary/encoding-and-decoding",draft:!1,unlisted:!1,editUrl:"https://github.com/cranst0n/ribs/edit/main/website/docs/binary/encoding-and-decoding.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"BitVector",permalink:"/ribs/docs/binary/bit-vector"},next:{title:"Streaming",permalink:"/ribs/docs/binary/streaming"}},l={},h=[{value:"Codec",id:"codec",level:2}];function g(e){const n={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,d.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"encoding-and-decoding",children:"Encoding and Decoding"}),"\n",(0,s.jsxs)(n.p,{children:["Much like Ribs JSON library, Ribs lets you define binary ",(0,s.jsx)(n.code,{children:"Codec"}),"s that make it\nvery easy to get complete control over decoding and encoding your Dart objects\nto binary data."]}),"\n",(0,s.jsx)(n.p,{children:"Let's start with a hypothical set of models."}),"\n",(0,s.jsx)(c.O,{language:"dart",title:"Domain Model",snippet:o,section:"codecs-1"}),"\n",(0,s.jsx)(n.h2,{id:"codec",children:"Codec"}),"\n",(0,s.jsxs)(n.p,{children:["To start, we'll define a ",(0,s.jsx)(n.code,{children:"Codec"})," for the ",(0,s.jsx)(n.code,{children:"Info"})," and ",(0,s.jsx)(n.code,{children:"Debug"})," classes:"]}),"\n",(0,s.jsx)(c.O,{language:"dart",title:"Subclass Codecs",snippet:o,section:"codecs-2"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"infoCodec"})," uses the ",(0,s.jsx)(n.code,{children:"utf16_32"})," codec which prefixes a 32-bit integer,\nindicating the length of the encoded string and then the string itself\nusing a UTF16 encoding."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"debugCodec"})," needs to use 2 different codecs to properly encode/decode\nthe 2 fields from the ",(0,s.jsx)(n.code,{children:"Debug"})," class:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"int32L"}),": Serializes the ",(0,s.jsx)(n.code,{children:"int"})," as little endian using 32-bits"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ascii32"}),": Serializes the string using ASCII, while prepending a 32-bit\ninteger to indicate the length of the string."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Next, we'll define a ",(0,s.jsx)(n.code,{children:"Codec"})," for ",(0,s.jsx)(n.code,{children:"Message"}),", the superclass of ",(0,s.jsx)(n.code,{children:"Info"})," and ",(0,s.jsx)(n.code,{children:"Debug"}),":"]}),"\n",(0,s.jsx)(c.O,{language:"dart",title:"Superclass Discriminator Codec",snippet:o,section:"codecs-3"}),"\n",(0,s.jsxs)(n.p,{children:["Here we use ",(0,s.jsx)(n.code,{children:"discriminatedBy"})," to allow us to properly encode and decode\ninstances of ",(0,s.jsx)(n.code,{children:"Message"})," by prefixing an unique indentifier tag before each\nmessage. In this particular instance, that tag is an 8-bit integer."]}),"\n",(0,s.jsxs)(n.p,{children:["The only pieces left are the codecs for ",(0,s.jsx)(n.code,{children:"Header"})," and ",(0,s.jsx)(n.code,{children:"Document"}),":"]}),"\n",(0,s.jsx)(c.O,{language:"dart",title:"Domain Model",snippet:o,section:"codecs-4"}),"\n",(0,s.jsxs)(n.p,{children:["Finally let's see how you can use the ",(0,s.jsx)(n.code,{children:"Codec"})," to encode and decode binary data:"]}),"\n",(0,s.jsx)(c.O,{language:"dart",title:"Domain Model",snippet:o,section:"codecs-5"}),"\n",(0,s.jsxs)(n.p,{children:["The example above illustrates a successful encoding of a ",(0,s.jsx)(n.code,{children:"Document"})," and then a\nsuccessful decoding of those previously encoded bits."]})]})}function u(e={}){const{wrapper:n}={...(0,d.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}}}]);