"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7604],{920(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>p,frontMatter:()=>c,metadata:()=>i,toc:()=>m});const i=JSON.parse('{"id":"binary/streaming","title":"Streaming","description":"It\'s a common scenario to read and write bytes to and from file, socket or","source":"@site/docs/binary/streaming.mdx","sourceDirName":"binary","slug":"/binary/streaming","permalink":"/ribs/docs/binary/streaming","draft":false,"unlisted":false,"editUrl":"https://github.com/cranst0n/ribs/edit/main/website/docs/binary/streaming.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Encoding and Decoding","permalink":"/ribs/docs/binary/encoding-and-decoding"},"next":{"title":"Iso","permalink":"/ribs/docs/optics/iso"}}');var s=t(4848),r=t(8453),a=t(2045);const o="// ignore_for_file: unused_local_variable\n\nimport 'dart:io';\n\nimport 'package:ribs_binary/ribs_binary.dart';\n\n// streaming-1\n\nfinal class Event {\n  final DateTime timestamp;\n  final int id;\n  final String message;\n\n  const Event(this.timestamp, this.id, this.message);\n\n  static final codec = Codec.product3(\n    Codec.int64.xmap(\n      (i) => DateTime.fromMillisecondsSinceEpoch(i),\n      (date) => date.millisecondsSinceEpoch,\n    ),\n    Codec.uint24,\n    Codec.utf8_32,\n    Event.new,\n    (evt) => (evt.timestamp, evt.id, evt.message),\n  );\n}\n\n// streaming-1\n\nFuture<void> snippet2() async {\n  // streaming-2\n\n  Stream<Event> events() => throw UnimplementedError('TODO');\n\n  final socket = await Socket.connect('localhost', 12345);\n\n  final Future<void> eventWriter = events()\n      // Encodes each Event to BitVector\n      .transform(StreamEncoder(Event.codec))\n      // Convert BitVector to Uint8List\n      .map((bitVector) => bitVector.toByteArray())\n      // Write each Uint8List to Socket\n      .forEach((byteList) => socket.add(byteList));\n\n  // streaming-2\n}\n\nFuture<void> snippet3() async {\n  // streaming-3\n  void storeEvent(Event evt) => throw UnimplementedError('TODO');\n\n  Future<void> handleClient(Socket clientSocket) => clientSocket\n      // Convert Uint8List to BitVector\n      .map((bytes) => ByteVector(bytes).bits)\n      // Convert BitVector to Event\n      .transform(StreamDecoder(Event.codec))\n      // Do something with the events\n      .forEach(storeEvent);\n\n  final socket = await ServerSocket.bind('0.0.0.0', 12345);\n  final events = socket.forEach(handleClient);\n\n  // streaming-3\n}\n",c={sidebar_position:3},d="Streaming",l={},m=[{value:"StreamEncoder",id:"streamencoder",level:2},{value:"StreamDecoder",id:"streamdecoder",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"streaming",children:"Streaming"})}),"\n",(0,s.jsxs)(n.p,{children:["It's a common scenario to read and write bytes to and from file, socket or\nsome other ",(0,s.jsx)(n.code,{children:"Stream"}),". Ribs provides the 2 basic tools to handle the machinery\nnecessary for these situations."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's assume we've got a simple type of model with our binary ",(0,s.jsx)(n.code,{children:"Codec"})," already\ndefined:"]}),"\n",(0,s.jsx)(a.z,{language:"dart",title:"Domain Model",snippet:o,section:"streaming-1"}),"\n",(0,s.jsx)(n.h2,{id:"streamencoder",children:"StreamEncoder"}),"\n",(0,s.jsxs)(n.p,{children:["Now image we generate these events on the fly and need to send them out a\nsocket after converting them to binary. ",(0,s.jsx)(n.code,{children:"StreamEncoder"})," is the perfect\nsolution:"]}),"\n",(0,s.jsx)(a.z,{language:"dart",title:"StreamEncoder",snippet:o,section:"streaming-2"}),"\n",(0,s.jsx)(n.p,{children:"We've built a capable yet expressive and readable program with minimal effort!"}),"\n",(0,s.jsx)(n.h2,{id:"streamdecoder",children:"StreamDecoder"}),"\n",(0,s.jsx)(n.p,{children:"Now we can imagine needing to write a program that will receive events off a\nsocket and do something meaningful with them:"}),"\n",(0,s.jsx)(a.z,{language:"dart",title:"StreamEncoder",snippet:o,section:"streaming-3"}),"\n",(0,s.jsx)(n.p,{children:"Using the Ribs Binary streaming API, it's easy to transform byte streams into\nyour domain objects."})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},2045(e,n,t){t.d(n,{z:()=>a});t(6540);var i=t(3457),s=t(4848);function r(e,n,t){if(null!=n){let t=`// ${n}`,s=e.indexOf(t);if(console.log(s),s>=0){for(;"\n"!=e[s];)s+=1;s+=1}let r=e.indexOf(t,s+1);if(0<=s){var i=(e=e.substring(s,r>=0?r:void 0).trimEnd()).split("\n");if(i.length>0){for(;0==i[0].length;)i.shift();let e=i[0].search(/\S|$/);return i.map(n=>"\n"==n?n:n.substring(e)).join("\n")}return e}return"// Oops! Snippet not found!"}return e}const a=({snippet:e,title:n,section:t,metastring:a})=>null==n||""==n?(0,s.jsx)(i.A,{metastring:a,children:r(e,t)}):(0,s.jsxs)("div",{className:"snippet",children:[(0,s.jsxs)("div",{className:"snippet__title_bar",children:[(0,s.jsxs)("div",{className:"snippet__dots",children:[(0,s.jsx)("div",{className:"snippet__dot"}),(0,s.jsx)("div",{className:"snippet__dot"}),(0,s.jsx)("div",{className:"snippet__dot"})]}),(0,s.jsx)("div",{className:"snippet__title",children:n})]}),(0,s.jsx)(i.A,{metastring:a,children:r(e,t)})]})}}]);