"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[81],{4848:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>u});var t=i(5893),r=i(1151),s=i(4214);const a="// ignore_for_file: avoid_print, unused_local_variable, dangling_library_doc_comments\n\n// overview-1\n\nint opCount = 0;\n\nint performOp(int a, int b) {\n  opCount += 1; // Mutating global variable!\n  return a + b;\n}\n\n// overview-1\n\n// overview-2\n\nint multiply(int a, int b) {\n  print('multipying $a x $b'); // Side effect!\n  return a * b;\n}\n\n// overview-2\n\n// overview-3\n\nfinal class Tracker {\n  int count = 0;\n\n  Tracker();\n}\n\nint doubleHeadAndSum(int a, int b, Tracker tracker) {\n  tracker.count += 1; // Modifying a field on the Tracker parameter\n  return a + b * a;\n}\n\n// overview-3\n\n// overview-4\n\nbool fireMissile(int passcode) {\n  if (passcode == 123) {\n    return true;\n  } else {\n    throw Exception('Missle launch aborted: Invalid passcode!');\n  }\n}\n\n// overview-4\n\n// overview-5\n\nint pureAdd(int a, int b) => a + b;\n\n// overview-5\n\n// overview-6\n\nfinal class Counter {\n  int count = 0;\n\n  Counter add() {\n    count += 1;\n    return this;\n  }\n}\n\nfinal counter = Counter();\nfinal b = counter.add();\nfinal resA = b.count;\nfinal resB = b.count;\n\nfinal areEqual = resA == resB; // Both values here equal 1\n\n// overview-6\n\nvoid snippet7() {\n  // overview-7\n\n  final counter = Counter();\n  // final b = a.add(); // We replace all occurances of b with a.add();\n  final resA = counter.add().count;\n  final resB = counter.add().count;\n\n  final areEqual = resA == resB; // Oh no! resA == 1 while resB == 2!\n\n  // overview-7\n}\n",o={sidebar_position:1},l="Overview",c={id:"overview",title:"Overview",description:"Ribs aims to provide useful libraries built on the core principles of",source:"@site/docs/overview.mdx",sourceDirName:".",slug:"/overview",permalink:"/ribs/docs/overview",draft:!1,unlisted:!1,editUrl:"https://github.com/cranst0n/ribs/edit/main/website/docs/overview.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Acknowledgements",permalink:"/ribs/docs/acknowledgements"}},d={},u=[{value:"Side-Effects",id:"side-effects",level:2},{value:"Pure Functions",id:"pure-functions",level:2},{value:"Referential Transparency",id:"referential-transparency",level:2},{value:"Additional Resources",id:"additional-resources",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["Ribs aims to provide useful libraries built on the core principles of\nfunctional programming (FP). FP is based on a core idea that we should write\nprograms that only use ",(0,t.jsx)(n.strong,{children:"pure functions"})," that are ",(0,t.jsx)(n.strong,{children:"side-effect free"})," and follow\nthe rules of ",(0,t.jsx)(n.strong,{children:"referential transparency"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Let's work through what each of those properties mean in practice:"}),"\n",(0,t.jsx)(n.h2,{id:"side-effects",children:"Side-Effects"}),"\n",(0,t.jsx)(n.p,{children:"To be brief, side effects are any action taken within a program other than\nreturning a result. Common examples of side effects include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Mutating a variable","\n",(0,t.jsx)(s.O,{language:"dart",snippet:a,section:"overview-1"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Printing to console","\n",(0,t.jsx)(s.O,{language:"dart",snippet:a,section:"overview-2"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Changing a field of an object","\n",(0,t.jsx)(s.O,{language:"dart",snippet:a,section:"overview-3"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Throwing an ",(0,t.jsx)(n.code,{children:"Exception"}),"\n",(0,t.jsx)(s.O,{language:"dart",snippet:a,section:"overview-4"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Eliminating side-effects from our programs allows us to write pure functions."}),"\n",(0,t.jsx)(n.h2,{id:"pure-functions",children:"Pure Functions"}),"\n",(0,t.jsxs)(n.p,{children:["A pure function should take it's parameters, compute a result and return that\nresult. ",(0,t.jsx)(n.strong,{children:"It should do nothing else!"})," If a function has any effect on the overall\nstate of the program, it cannot be considered pure and violates a core\nprinciple of FP."]}),"\n",(0,t.jsx)(n.p,{children:"One of the simplest examples of this below:"}),"\n",(0,t.jsx)(s.O,{language:"dart",snippet:a,section:"overview-5"}),"\n",(0,t.jsx)(n.p,{children:"This simple function takes it's inputs and the result of the function is\nentirely dependent on the input. Using pure functions allows us to use local\nreasoning, in that we only need to understand what is happening in the function\nitself, rather than needing to know any kind of context surrounding the\nfunction call."}),"\n",(0,t.jsx)(n.h2,{id:"referential-transparency",children:"Referential Transparency"}),"\n",(0,t.jsx)(n.p,{children:"A simplistic definition of referential transparency (RT) refers to a property\nwhere any expression (E) can be safely replaced by the result of evaluating\nthat expression. Safely means that the replacing or substitution does not\nchange the result of the entire program."}),"\n",(0,t.jsx)(n.p,{children:"Building on our definitions let's look at 2 examples that illustrate when RT\nis satisfied and when it is violated:"}),"\n",(0,t.jsx)(s.O,{language:"dart",title:"Initial Program",snippet:a,section:"overview-6"}),"\n",(0,t.jsxs)(n.p,{children:["Now let's try substituting every occurance of ",(0,t.jsx)(n.code,{children:"b"})," with the expression that ",(0,t.jsx)(n.code,{children:"b"}),"\nevaluated to, namely ",(0,t.jsx)(n.code,{children:"a.add()"}),":"]}),"\n",(0,t.jsx)(s.O,{language:"dart",title:"Broken Referential Transparency",snippet:a,section:"overview-7"}),"\n",(0,t.jsxs)(n.p,{children:["After doing the substitution, we can see that RT is broken since the value of\n",(0,t.jsx)(n.code,{children:"areEqual"})," changes. The ultimate reason behind this is that the ",(0,t.jsx)(n.code,{children:"Counter.add"}),"\nfunction is not a pure function. It changes the mutable field ",(0,t.jsx)(n.code,{children:"count"})," and then\nreturns itself, which is clearly a side effect."]}),"\n",(0,t.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/fpinscala/fpinscala/wiki/Chapter-1:-What-is-functional-programming%3F",children:"What is functional programming"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}}}]);