"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[440],{6778:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>p,toc:()=>d});var a=t(7462),r=(t(7294),t(3905)),i=t(4214);const s="// ignore_for_file: unused_local_variable\n\nimport 'dart:io';\n\nimport 'package:ribs_core/ribs_core.dart';\nimport 'package:ribs_json/ribs_json.dart';\n\n/// streaming-1\n\nfinal class Event {\n  final String id;\n  final String type;\n  final Repo repo;\n\n  const Event(this.id, this.type, this.repo);\n\n  static final codec = Codec.product3(\n    'id'.as(Codec.string),\n    'type'.as(Codec.string),\n    'repo'.as(Repo.codec),\n    Event.new,\n    (evt) => (evt.id, evt.type, evt.repo),\n  );\n}\n\nfinal class Repo {\n  final int id;\n  final String name;\n\n  const Repo(this.id, this.name);\n\n  static final codec = Codec.product2(\n    'id'.as(Codec.integer),\n    'name'.as(Codec.string),\n    Repo.new,\n    (repo) => (repo.id, repo.name),\n  );\n}\n\n/// streaming-1\n\n/// streaming-2\n\n// Original stream of bytes\nfinal Stream<List<int>> byteStream =\n    File('path/to/big-array-file.json').openRead();\n\n// Use JsonTransformer to transform the bytes into individual JSON events\nfinal Stream<Json> jsonStream =\n    byteStream.transform(JsonTransformer.bytes(AsyncParserMode.unwrapArray));\n\n// Decode each Json stream element into an event, accounting for failure\nfinal Stream<Either<DecodingFailure, Event>> decodeStream =\n    jsonStream.map((json) => Event.codec.decode(json));\n\n// One step further...drop any decoding errors\nfinal Stream<Event> eventStream = decodeStream.expand((element) => element.fold(\n      (err) => <Event>[],\n      (event) => [event],\n    ));\n\n/// streaming-2\n\nFuture<void> snippet3() async {\n  /// streaming-3\n\n  final Socket sock = await Socket.connect('192.168.0.100', 12345);\n\n  final Stream<Json> jsonStream = sock\n      .map((event) => event.toList())\n      .transform(JsonTransformer.bytes(AsyncParserMode.valueStream));\n\n  /// streaming-3\n}\n",o={sidebar_position:4},l="Streaming",p={unversionedId:"json/streaming",id:"json/streaming",title:"Streaming",description:"Ribs JSON also comes with an AsyncParser that supports emitting JSON elements",source:"@site/docs/json/streaming.mdx",sourceDirName:"json",slug:"/json/streaming",permalink:"/ribs/docs/json/streaming",draft:!1,editUrl:"https://github.com/cranst0n/ribs/edit/main/website/docs/json/streaming.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Encoding and Decoding",permalink:"/ribs/docs/json/encoding-and-decoding"},next:{title:"BitVector",permalink:"/ribs/docs/binary/bit-vector"}},m={},d=[{value:"Unwrap Array",id:"unwrap-array",level:2},{value:"Value Stream",id:"value-stream",level:2},{value:"Single Value",id:"single-value",level:2}],c={toc:d},u="wrapper";function h(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"streaming"},"Streaming"),(0,r.kt)("p",null,"Ribs JSON also comes with an ",(0,r.kt)("inlineCode",{parentName:"p"},"AsyncParser")," that supports emitting JSON elements\nas they arrive in situations like reading bytes from a file or a streaming HTTP\nresponse."),(0,r.kt)("h2",{id:"unwrap-array"},"Unwrap Array"),(0,r.kt)("p",null,"The first mode of streaming Ribs supports is ",(0,r.kt)("inlineCode",{parentName:"p"},"unwrapArray"),", which expects the\nstreamed JSON to consist of a top level JSON array. The parser will then emit\nevents as each child element is completely received."),(0,r.kt)("p",null,"To illustrate, let's start with a basic setup with a couple domain models and\nJSON codecs defined for each:"),(0,r.kt)(i.O,{language:"dart",title:"Models",snippet:s,section:"streaming-1",mdxType:"CodeSnippet"}),(0,r.kt)("p",null,"Now consider that the incoming JSON, (whether it be from a file, a socket or\nan HTTP response), will take on the following structure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "id": "2489651045",\n        "type": "CreateEvent",\n        "repo": {\n            "id": 28688495,\n            "name": "petroav/6.828",\n            "url": "https://api.github.com/repos/petroav/6.828"\n        }\n    },\n    {\n        "id": "2489651051",\n        "type": "PushEvent",\n        "repo": {\n            "id": 28671719,\n            "name": "rspt/rspt-theme",\n            "url": "https://api.github.com/repos/rspt/rspt-theme"\n        }\n    },\n    //\n    //     Tens, hundreds, thousands of more events....\n    //\n    {\n        "id": "2489651591",\n        "type": "WatchEvent",\n        "repo": {\n            "id": 21289110,\n            "name": "vinta/awesome-python",\n            "url": "https://api.github.com/repos/vinta/awesome-python"\n        }\n    }\n]\n')),(0,r.kt)("p",null,"We can emit each of these individual ",(0,r.kt)("inlineCode",{parentName:"p"},"Event"),"s using the ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonTransformer"),"\nin the Ribs Json library. Here's a simple example of how it's used:"),(0,r.kt)(i.O,{language:"dart",title:"Unwrap Array Transformer",snippet:s,section:"streaming-2",mdxType:"CodeSnippet"}),(0,r.kt)("h2",{id:"value-stream"},"Value Stream"),(0,r.kt)("p",null,"In the case the stream contains multiple top-level JSON elements, you'll want\nto use ",(0,r.kt)("inlineCode",{parentName:"p"},"AsyncParserMode.valueStream")," when creating your ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonTransformer"),"."),(0,r.kt)("p",null,"Consider the incoming JSON will look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'["Name", "Session", "Score", "Completed"]\n{"name": "Gilbert", "wins": [["straight", "7\u2663"], ["one pair", "10\u2665"]]}\n["Gilbert", "2013", 24, true]\n//\n//    tens, hundreds, thousands of other JSON elements...\n//\n{"name": "Deloise", "wins": [["three of a kind", "5\u2663"]]}\n["Deloise", "2012A", 19, true]\n')),(0,r.kt)("p",null,"We'll creating our transformer in exactly the same way, but change the mode\nthe parser will operate as:"),(0,r.kt)(i.O,{language:"dart",title:"Value Stream Transformer",snippet:s,section:"streaming-3",mdxType:"CodeSnippet"}),(0,r.kt)("h2",{id:"single-value"},"Single Value"),(0,r.kt)("p",null,"The last mode available expects a single top level JSON element and won't emit\nthe JSON event until it's entirely received. This effectively turns the\n",(0,r.kt)("inlineCode",{parentName:"p"},"JsonTransformer")," into a standard synchronous parser but could still be useful\nin some situations."))}h.isMDXComponent=!0}}]);