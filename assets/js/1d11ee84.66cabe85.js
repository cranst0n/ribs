"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[626],{1038:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>d,toc:()=>u});var i=t(5893),o=t(1151),s=t(4214);const r="import 'package:ribs_core/ribs_core.dart';\n\n// aliases-1\n\ntypedef Function1<A, B> = B Function(A);\ntypedef Function2<A, B, C> = C Function(A, B);\n\n// These 2 function signatures are identical\nint dartFun(String Function(double) f) => throw UnimplementedError();\nint ribsFun(Function1<double, String> f) => throw UnimplementedError();\n\n// aliases-1\n\n// andThen-1\n\nint addOne(int x) => x + 1;\nint doubleIt(int x) => x * 2;\n\nfinal addOneThenDouble = addOne.andThen(doubleIt);\n\nfinal a = addOneThenDouble(0); // (0 + 1) * 2 == 2\nfinal b = addOneThenDouble(2); // (2 + 1) * 2 == 6\n\n// andThen-1\n\n// compose-1\n\nfinal doubleItThenAddOne = addOne.compose(doubleIt);\n\nfinal c = doubleItThenAddOne(0); // (0 * 2) + 1 == 1\nfinal d = doubleItThenAddOne(2); // (2 * 2) + 1 == 5\n\n// compose-1\n\n// currying-1\n\n// Converts a function from:\n//     (A, B) => C\n// to:\n//     A => B => C\nFunction1<A, Function1<B, C>> curryFn<A, B, C>(Function2<A, B, C> f) =>\n    throw UnimplementedError('???');\n\n// currying-1\n\n// curryFn-impl\n\nFunction1<A, Function1<B, C>> curryFnImpl<A, B, C>(Function2<A, B, C> f) =>\n    (a) => (b) => f(a, b);\n\n// curryFn-impl\n\n// currying-2\n\nint add2(int a, int b) => a + b;\n\n// Ribs also provides type aliases for curried functions that take the form\n// of FunctionNC, where the 'C' denotes the function is curried.\nfinal Function2C<int, int, int> add2Curried = add2.curried;\n\n// currying-2\n\n// currying-3\n\nint add3(int a, int b, int c) => a + b + c;\n\nfinal Function3C<int, int, int, int> add3Curried = add3.curried;\nfinal Function3<int, int, int, int> add3Uncurried = add3Curried.uncurried;\n\n// currying-3\n\n// tupled-1\n\nint fun(int a, String b, bool c) => throw UnimplementedError();\n\nFunction1<(int, String, bool), int> funTupled = fun.tupled;\n\nfinal result = funTupled((2, 'Hello!', false));\n\n// tupled-1\n",a={sidebar_position:1},c="Functions",d={id:"core/functions",title:"Functions",description:"Shockingly, functions are one of the core elements of the functional",source:"@site/docs/core/functions.mdx",sourceDirName:"core",slug:"/core/functions",permalink:"/ribs/docs/core/functions",draft:!1,unlisted:!1,editUrl:"https://github.com/cranst0n/ribs/edit/main/website/docs/core/functions.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Acknowledgements",permalink:"/ribs/docs/acknowledgements"},next:{title:"Option",permalink:"/ribs/docs/core/option"}},l={},u=[{value:"Aliases",id:"aliases",level:2},{value:"Composition",id:"composition",level:2},{value:"andThen",id:"andthen",level:3},{value:"compose",id:"compose",level:3},{value:"Currying",id:"currying",level:2},{value:"Tupled",id:"tupled",level:2}];function h(n){const e={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,o.a)(),...n.components},{Details:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"functions",children:"Functions"}),"\n",(0,i.jsx)(e.p,{children:"Shockingly, functions are one of the core elements of the functional\nprogramming paradigm. Accordingly, Ribs provides some tools to work with\nfunctions themselves."}),"\n",(0,i.jsx)(e.h2,{id:"aliases",children:"Aliases"}),"\n",(0,i.jsx)(e.p,{children:"Ribs uses a set of type aliases to make reading function signatures\n(subjectively) easier. If you've spent any time working with Scala, these\naliases should look familiar:"}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Function-N Aliases",snippet:r,section:"aliases-1"}),"\n",(0,i.jsxs)(e.p,{children:["The ",(0,i.jsx)(e.code,{children:"1"})," in ",(0,i.jsx)(e.code,{children:"Function1"})," indicates that the function takes ",(0,i.jsx)(e.strong,{children:"one"})," parameter.\nPredictably, the ",(0,i.jsx)(e.code,{children:"2"})," in ",(0,i.jsx)(e.code,{children:"Function2"})," indicates the function takes ",(0,i.jsx)(e.strong,{children:"two"}),"\nparameters. Aliases exist up to 22. One benefit of these aliases is that the\ntype naturally reads left to right so we can quickly see that a\n",(0,i.jsx)(e.code,{children:"Function4<String, double, int, List<Foo>>"})," takes a ",(0,i.jsx)(e.code,{children:"String"}),", ",(0,i.jsx)(e.code,{children:"double"})," and ",(0,i.jsx)(e.code,{children:"int"}),"\nand will return a value of type ",(0,i.jsx)(e.code,{children:"List<Foo>"}),"."]}),"\n",(0,i.jsx)(e.admonition,{type:"info",children:(0,i.jsx)(e.p,{children:"You don't have to use these aliases in your own code but they're worth familiarizing\nyourself with since they're used throughout the Ribs API."})}),"\n",(0,i.jsx)(e.h2,{id:"composition",children:"Composition"}),"\n",(0,i.jsx)(e.p,{children:"Functions are one of the smallest building blocks of our programs. To create\nuseful programs though, we'll need to use many functions together. How do they\nfit together though? That's a pretty general question but Ribs does provide a\nfew ways to help you along the way as you gradually combine your small functions\ninto something larger."}),"\n",(0,i.jsx)(e.h3,{id:"andthen",children:"andThen"}),"\n",(0,i.jsx)(e.p,{children:"It's often the case you'll want to feed the output of one function into another:"}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Simple andThen Example",snippet:r,section:"andThen-1"}),"\n",(0,i.jsx)(e.p,{children:"While this example is a bit trivial, you'll likely come across instances on\nyour FP journey where chaining two function into a single value that you can\nthen pass around will result in a cleaner and more composable solution."}),"\n",(0,i.jsx)(e.h3,{id:"compose",children:"compose"}),"\n",(0,i.jsxs)(e.p,{children:["Using the same function definitions from above we can ",(0,i.jsx)(e.code,{children:"compose"})," two functions:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Simple compose Example",snippet:r,section:"compose-1"}),"\n",(0,i.jsxs)(e.p,{children:["Examining the behavior of ",(0,i.jsx)(e.code,{children:"andThen"})," and ",(0,i.jsx)(e.code,{children:"compose"})," leads to the conclusion that\n",(0,i.jsx)(e.code,{children:"f.compose(g)"})," is the same as ",(0,i.jsx)(e.code,{children:"g.andThen(f)"}),"."]}),"\n",(0,i.jsx)(e.h2,{id:"currying",children:"Currying"}),"\n",(0,i.jsxs)(e.p,{children:["Ribs also provides functions to curry and uncurry functions. Currying is the\nprocess of taking a function ",(0,i.jsx)(e.code,{children:"f"})," that takes N parameters and turning it into a\nfunction that takes one parameter and returns a partially applied version of\n",(0,i.jsx)(e.code,{children:"f"})," that takes N-1 parameters. Check out this example:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Currying",snippet:r,section:"currying-1"}),"\n",(0,i.jsx)(e.p,{children:"It's worth the time to work through implementing this function. But if you're\njust looking for a quick answer:"}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Curry Implementation"}),(0,i.jsx)("div",{children:(0,i.jsx)(s.O,{language:"dart",snippet:r,section:"curryFn-impl"})})]}),"\n",(0,i.jsxs)(e.p,{children:["Now that we know what currying is, we can use Ribs provided ",(0,i.jsx)(e.code,{children:"curried"})," function\nfor ",(0,i.jsx)(e.code,{children:"FunctionN"})," (where 0 < N < 23) like so:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Currying with Ribs",snippet:r,section:"currying-2"}),"\n",(0,i.jsxs)(e.p,{children:['This naturally begs the question: "Can you ',(0,i.jsx)(e.em,{children:(0,i.jsx)(e.strong,{children:"un"})}),'curry a function?". And\nthe answer is most definitely yes! Ribs provides this ability out of the box:']}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Uncurrying with Ribs",snippet:r,section:"currying-3"}),"\n",(0,i.jsx)(e.h2,{id:"tupled",children:"Tupled"}),"\n",(0,i.jsx)(e.p,{children:"One last, but very useful function that Ribs provides is the ability to convert\nfunctions from accepts a set of individual arguments to one that accepts a tuple\nof the same argument types:"}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Tupled Function",snippet:r,section:"tupled-1"}),"\n",(0,i.jsx)(e.p,{children:"You may be asking why this would ever be useful but it becomes more apparent as\nyou start working with generic endcoders/decoders, data classes (which Dart doesn't\ncurrently support) and tuple destructuring among other things. It's always\ngood to stick this one in your back pocket to pull out when the situation arises."})]})}function p(n={}){const{wrapper:e}={...(0,o.a)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(h,{...n})}):h(n)}}}]);