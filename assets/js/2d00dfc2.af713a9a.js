"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[174],{5649:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>d,toc:()=>l});var i=t(5893),r=t(1151),s=t(4214);const o="// ignore_for_file: unused_local_variable\n\nimport 'dart:io';\n\nimport 'package:ribs_binary/ribs_binary.dart';\n\n// streaming-1\n\nfinal class Event {\n  final DateTime timestamp;\n  final int id;\n  final String message;\n\n  const Event(this.timestamp, this.id, this.message);\n\n  static final codec = Codec.product3(\n    Codec.int64.xmap(\n      (i) => DateTime.fromMillisecondsSinceEpoch(i),\n      (date) => date.millisecondsSinceEpoch,\n    ),\n    Codec.uint24,\n    Codec.utf8_32,\n    Event.new,\n    (evt) => (evt.timestamp, evt.id, evt.message),\n  );\n}\n\n// streaming-1\n\nFuture<void> snippet2() async {\n  // streaming-2\n\n  Stream<Event> events() => throw UnimplementedError('TODO');\n\n  final socket = await Socket.connect('localhost', 12345);\n\n  final Future<void> eventWriter = events()\n      // Encodes each Event to BitVector\n      .transform(StreamEncoder(Event.codec))\n      // Convert BitVector to Uint8List\n      .map((bitVector) => bitVector.toByteArray())\n      // Write each Uint8List to Socket\n      .forEach((byteList) => socket.add(byteList));\n\n  // streaming-2\n}\n\nFuture<void> snippet3() async {\n  // streaming-3\n  void storeEvent(Event evt) => throw UnimplementedError('TODO');\n\n  Future<void> handleClient(Socket clientSocket) => clientSocket\n      // Convert Uint8List to BitVector\n      .map((bytes) => ByteVector(bytes).bits)\n      // Convert BitVector to Event\n      .transform(StreamDecoder(Event.codec))\n      // Do something with the events\n      .forEach(storeEvent);\n\n  final socket = await ServerSocket.bind('0.0.0.0', 12345);\n  final events = socket.forEach(handleClient);\n\n  // streaming-3\n}\n",a={sidebar_position:3},c="Streaming",d={id:"binary/streaming",title:"Streaming",description:"It's a common scenario to read and write bytes to and from file, socket or",source:"@site/docs/binary/streaming.mdx",sourceDirName:"binary",slug:"/binary/streaming",permalink:"/ribs/docs/binary/streaming",draft:!1,unlisted:!1,editUrl:"https://github.com/cranst0n/ribs/edit/main/website/docs/binary/streaming.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Encoding and Decoding",permalink:"/ribs/docs/binary/encoding-and-decoding"},next:{title:"Iso",permalink:"/ribs/docs/optics/iso"}},m={},l=[{value:"StreamEncoder",id:"streamencoder",level:2},{value:"StreamDecoder",id:"streamdecoder",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",p:"p",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"streaming",children:"Streaming"}),"\n",(0,i.jsxs)(n.p,{children:["It's a common scenario to read and write bytes to and from file, socket or\nsome other ",(0,i.jsx)(n.code,{children:"Stream"}),". Ribs provides the 2 basic tools to handle the machinery\nnecessary for these situations."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's assume we've got a simple type of model with our binary ",(0,i.jsx)(n.code,{children:"Codec"})," already\ndefined:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"Domain Model",snippet:o,section:"streaming-1"}),"\n",(0,i.jsx)(n.h2,{id:"streamencoder",children:"StreamEncoder"}),"\n",(0,i.jsxs)(n.p,{children:["Now image we generate these events on the fly and need to send them out a\nsocket after converting them to binary. ",(0,i.jsx)(n.code,{children:"StreamEncoder"})," is the perfect\nsolution:"]}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"StreamEncoder",snippet:o,section:"streaming-2"}),"\n",(0,i.jsx)(n.p,{children:"We've built a capable yet expressive and readable program with minimal effort!"}),"\n",(0,i.jsx)(n.h2,{id:"streamdecoder",children:"StreamDecoder"}),"\n",(0,i.jsx)(n.p,{children:"Now we can imagine needing to write a program that will receive events off a\nsocket and do something meaningful with them:"}),"\n",(0,i.jsx)(s.O,{language:"dart",title:"StreamEncoder",snippet:o,section:"streaming-3"}),"\n",(0,i.jsx)(n.p,{children:"Using the Ribs Binary streaming API, it's easy to transform byte streams into\nyour domain objects."})]})}function p(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);