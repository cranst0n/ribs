"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[933],{908:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>m,frontMatter:()=>d,metadata:()=>r,toc:()=>p});var t=i(7462),o=(i(7294),i(3905)),s=i(4214);const a="// ignore_for_file: avoid_print\n\nimport 'package:ribs_binary/ribs_binary.dart';\nimport 'package:ribs_core/ribs_core.dart';\n\n/// codecs-1\n\nfinal class Document {\n  final Header header;\n  final IList<Message> messages;\n\n  const Document(this.header, this.messages);\n}\n\nfinal class Header {\n  final double version;\n  final String comment;\n  final int numMessages;\n\n  const Header(this.version, this.comment, this.numMessages);\n}\n\nsealed class Message {}\n\nfinal class Info extends Message {\n  final String message;\n\n  Info(this.message);\n}\n\nfinal class Debug extends Message {\n  final int lineNumber;\n  final String message;\n\n  Debug(this.lineNumber, this.message);\n}\n\n/// codecs-1\n\n/// codecs-2\n\nfinal infoCodec = utf16_32.xmap((str) => Info(str), (info) => info.message);\n\nfinal debugCodec = Codec.product2(\n  int32L, // 32-bit little endian int\n  ascii32, // ascii bytes with 32bit size prefix\n  Debug.new,\n  (dbg) => (dbg.lineNumber, dbg.message),\n);\n\n/// codecs-2\n\n/// codecs-3\n\nfinal messageCodec = discriminatedBy(\n  uint8, // encode identifier using an 8-bit integer\n  imap({\n    0: infoCodec, // instances of Info prefixed by ID 0\n    1: debugCodec, // instances of Debug prefixed by ID 1\n  }),\n);\n\n/// codecs-3\n\n/// codecs-4\n\nfinal documentCodec = Codec.product2(\n  headerCodec,\n  // ilist of Messages with 16-bit int prefix indicating # of elements\n  ilistOfN(int16, messageCodec),\n  Document.new,\n  (doc) => (doc.header, doc.messages),\n);\n\nfinal headerCodec = Codec.product3(\n  float32, // 32-bit floating point\n  utf8_32, // utf8 bytes with 32bit size prefix\n  int64, // 64-bit integer\n  (version, comment, numMessages) => Header(version, comment, numMessages),\n  (hdr) => (hdr.version, hdr.comment, hdr.numMessages),\n);\n\n/// codecs-4\n\nvoid snippet5() {\n  /// codecs-5\n  final doc = Document(\n      const Header(1.1, 'Top Secret', 3),\n      IList.of([\n        Info('Hello!'),\n        Debug(123, 'breakpoint-1'),\n        Info('Goodbye!'),\n      ]));\n\n  // Encoding will give us an error or the successfully encoded BitVector\n  final Either<Err, BitVector> bits = documentCodec.encode(doc);\n\n  print(bits);\n  // Right(3f8ccccd00000050546f702053656372657400000000000000030003000000003048656c6c6f21017b00000000000060627265616b706f696e742d310000000040476f6f6462796521)\n\n  // Decoding will give us either an error if it failed or the DecodeResult\n  // A DecodeResult gives us the successfully decoded value and any remaining bits from the input\n  // ** Note the throw is included only for edification purposes. This is not a good idea in production code\n  final Either<Err, DecodeResult<Document>> decoded = documentCodec\n      .decode(bits.getOrElse(() => throw Exception('encode failed!')));\n\n  print(decoded);\n  // Right(DecodeResult(Instance of 'Document', ByteVector.empty))\n\n  /// codecs-5\n}\n",d={sidebar_position:2},c="Encoding and Decoding",r={unversionedId:"binary/encoding-and-decoding",id:"binary/encoding-and-decoding",title:"Encoding and Decoding",description:"Much like Ribs JSON library, Ribs lets you define binary Codecs that make it",source:"@site/docs/binary/encoding-and-decoding.mdx",sourceDirName:"binary",slug:"/binary/encoding-and-decoding",permalink:"/ribs/docs/binary/encoding-and-decoding",draft:!1,editUrl:"https://github.com/cranst0n/ribs/edit/main/website/docs/binary/encoding-and-decoding.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"BitVector",permalink:"/ribs/docs/binary/bit-vector"},next:{title:"Streaming",permalink:"/ribs/docs/binary/streaming"}},l={},p=[{value:"Codec",id:"codec",level:2}],u={toc:p},g="wrapper";function m(e){let{components:n,...i}=e;return(0,o.kt)(g,(0,t.Z)({},u,i,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"encoding-and-decoding"},"Encoding and Decoding"),(0,o.kt)("p",null,"Much like Ribs JSON library, Ribs lets you define binary ",(0,o.kt)("inlineCode",{parentName:"p"},"Codec"),"s that make it\nvery easy to get complete control over decoding and encoding your Dart objects\nto binary data."),(0,o.kt)("p",null,"Let's start with a hypothical set of models."),(0,o.kt)(s.O,{language:"dart",title:"Domain Model",snippet:a,section:"codecs-1",mdxType:"CodeSnippet"}),(0,o.kt)("h2",{id:"codec"},"Codec"),(0,o.kt)("p",null,"To start, we'll define a ",(0,o.kt)("inlineCode",{parentName:"p"},"Codec")," for the ",(0,o.kt)("inlineCode",{parentName:"p"},"Info")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Debug")," classes:"),(0,o.kt)(s.O,{language:"dart",title:"Subclass Codecs",snippet:a,section:"codecs-2",mdxType:"CodeSnippet"}),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"infoCodec")," uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"utf16_32")," codec which prefixes a 32-bit integer,\nindicating the length of the encoded string and then the string itself\nusing a UTF16 encoding."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"debugCodec")," needs to use 2 different codecs to properly encode/decode\nthe 2 fields from the ",(0,o.kt)("inlineCode",{parentName:"p"},"Debug")," class:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"int32L"),": Serializes the ",(0,o.kt)("inlineCode",{parentName:"li"},"int")," as little endian using 32-bits"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ascii32"),": Serializes the string using ASCII, while prepending a 32-bit\ninteger to indicate the length of the string.")),(0,o.kt)("p",null,"Next, we'll define a ",(0,o.kt)("inlineCode",{parentName:"p"},"Codec")," for ",(0,o.kt)("inlineCode",{parentName:"p"},"Message"),", the superclass of ",(0,o.kt)("inlineCode",{parentName:"p"},"Info")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Debug"),":"),(0,o.kt)(s.O,{language:"dart",title:"Superclass Discriminator Codec",snippet:a,section:"codecs-3",mdxType:"CodeSnippet"}),(0,o.kt)("p",null,"Here we use ",(0,o.kt)("inlineCode",{parentName:"p"},"discriminatedBy")," to allow us to properly encode and decode\ninstances of ",(0,o.kt)("inlineCode",{parentName:"p"},"Message")," by prefixing an unique indentifier tag before each\nmessage. In this particular instance, that tag is an 8-bit integer."),(0,o.kt)("p",null,"The only pieces left are the codecs for ",(0,o.kt)("inlineCode",{parentName:"p"},"Header")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Document"),":"),(0,o.kt)(s.O,{language:"dart",title:"Domain Model",snippet:a,section:"codecs-4",mdxType:"CodeSnippet"}),(0,o.kt)("p",null,"Finally let's see how you can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Codec")," to encode and decode binary data:"),(0,o.kt)(s.O,{language:"dart",title:"Domain Model",snippet:a,section:"codecs-5",mdxType:"CodeSnippet"}),(0,o.kt)("p",null,"The example above illustrates a successful encoding of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Document")," and then a\nsuccessful decoding of those previously encoded bits."))}m.isMDXComponent=!0}}]);