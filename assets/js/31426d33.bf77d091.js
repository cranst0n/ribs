"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6],{756:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>p,toc:()=>c});var o=t(7462),i=(t(7294),t(3905)),a=t(4214);const d="// ignore_for_file: avoid_print, unused_local_variable\n\nimport 'package:ribs_core/ribs_core.dart';\nimport 'package:ribs_json/ribs_json.dart';\n\n/// codecs-1\n\nfinal class User {\n  final String name;\n  final int age;\n  final IList<Pet> pets;\n\n  const User(this.name, this.age, this.pets);\n}\n\nfinal class Pet {\n  final String name;\n  final Option<double> weight;\n  final PetType type;\n\n  const Pet(this.name, this.weight, this.type);\n}\n\nenum PetType { mammal, reptile, other }\n\n/// codecs-1\n\nvoid snippet2() {\n  /// codecs-2\n  final petTypeDecoder = Decoder.integer.map((n) => PetType.values[n]);\n\n  final petDecoder = Decoder.product3(\n    Decoder.string.at('name'),\n    Decoder.dubble.optional().at('weight'),\n    petTypeDecoder.at('type'),\n    (name, weight, type) => Pet(name, weight, type),\n  );\n\n  final userDecoder = Decoder.product3(\n    Decoder.string.at('name'),\n    Decoder.integer.at('age'),\n    Decoder.ilist(petDecoder).at('pets'),\n    (name, age, pets) => User(name, age, pets),\n  );\n\n  const jsonStr = '''\n  {\n    \"name\": \"Joe\",\n    \"age\": 20,\n    \"pets\": [\n      { \"name\": \"Ribs\", \"weight\": 22.1, \"type\": 0 },\n      { \"name\": \"Lizzy\", \"type\": 11 }\n    ]\n  }\n  ''';\n\n  print(Json.decode(jsonStr, userDecoder));\n  // Right(Instance of 'User')\n\n  /// codecs-2\n}\n\nvoid snippet3() {\n  /// codecs-3\n  final petTypeDecoder = Decoder.integer.map((n) => PetType.values[n]);\n\n  print(Json.decode('0', petTypeDecoder)); // Right(PetType.mammal)\n  print(Json.decode('1', petTypeDecoder)); // Right(PetType.reptile)\n  print(Json.decode('2', petTypeDecoder)); // Right(PetType.other)\n  print(Json.decode('100', petTypeDecoder)); // ???\n\n  /// codecs-3\n}\n\nvoid snippet4() {\n  /// codecs-4\n  // Solution using .emap\n  final petTypeDecoderA = Decoder.integer.emap(\n    (n) => Either.cond(() => 0 <= n && n < PetType.values.length,\n        () => PetType.values[n], () => 'Invalid value index for PetType: $n'),\n  );\n\n  print(Json.decode('100', petTypeDecoderA));\n  // Left(DecodingFailure(CustomReason(Invalid PetType index: 100), None))\n\n  /// codecs-4\n}\n\n/// codecs-enumeration\n/// Uses Enum.index to look up instance\nfinal petTypeDecoderByIndex = Decoder.enumerationByIndex(PetType.values);\n\n/// Uses Enum.name to look up instance\nfinal petTypeDecoderByName = Decoder.enumerationByName(PetType.values);\n\n/// codecs-enumeration\n\nvoid snippet5() {\n  /// codecs-5\n  final petTypeEncoder = Encoder.instance((PetType t) => Json.number(t.index));\n  // Alternative PetType solution\n  final petTypeEncoderAlt = Encoder.integer.contramap<PetType>((t) => t.index);\n\n  final petEncoder = Encoder.instance(\n    (Pet p) => Json.obj(\n      [\n        ('name', Json.str(p.name)),\n        ('weight', p.weight.fold(() => Json.Null, (w) => Json.number(w))),\n        ('type', petTypeEncoder.encode(p.type)),\n      ],\n    ),\n  );\n\n  final userEncoder = Encoder.instance(\n    (User u) => Json.obj(\n      [\n        ('name', Json.str(u.name)),\n        ('age', Json.number(u.age)),\n        ('pets', Json.arrI(u.pets.map(petEncoder.encode))),\n      ],\n    ),\n  );\n\n  print(\n    userEncoder\n        .encode(\n          User(\n            'Henry',\n            40,\n            ilist([\n              const Pet('Ribs', Some(22.0), PetType.mammal),\n              const Pet('Lizzy', None(), PetType.reptile),\n            ]),\n          ),\n        )\n        .printWith(Printer.spaces2),\n  );\n  // {\n  //   \"name\" : \"Henry\",\n  //   \"age\" : 40,\n  //   \"pets\" : [\n  //     {\n  //       \"name\" : \"Ribs\",\n  //       \"weight\" : 22.0,\n  //       \"type\" : 0\n  //     },\n  //     {\n  //       \"name\" : \"Lizzy\",\n  //       \"weight\" : null,\n  //       \"type\" : 1\n  //     }\n  //   ]\n  // }\n  /// codecs-5\n}\n\nvoid snippet6() {\n  /// codecs-6\n  final petTypeCodec = Codec.integer.iemap(\n    (n) => Either.cond(\n      () => 0 <= n && n < PetType.values.length,\n      () => PetType.values[n],\n      () => 'Invalid PetType index: $n',\n    ),\n    (petType) => petType.index,\n  );\n\n  final petCodec = Codec.product3(\n    'name'.as(Codec.string), // Same as: Codec.string.atField('name'),\n    'weight'.as(Codec.dubble).optional(),\n    'type'.as(petTypeCodec),\n    Pet.new,\n    (p) => (p.name, p.weight, p.type),\n  );\n\n  final userCodec = Codec.product3(\n    'name'.as(Codec.string),\n    'age'.as(Codec.integer),\n    'pets'.as(Codec.ilist(petCodec)),\n    User.new, // Constructor tear-off\n    (u) => (u.name, u.age, u.pets), // Describe how to turn user into tuple\n  );\n\n  const jsonStr = '''\n  {\n    \"name\": \"Joe\",\n    \"age\": 20,\n    \"pets\": [\n      { \"name\": \"Ribs\", \"weight\": 22.1, \"type\": 0 },\n      { \"name\": \"Lizzy\", \"type\": 11 }\n    ]\n  }\n  ''';\n\n  // Codecs can decode and encode\n  final user = Json.decode(jsonStr, userCodec);\n  final str = userCodec.encode(const User('name', 20, IList.nil()));\n\n  /// codecs-6\n}\n\nvoid foo6() {}\n",r={sidebar_position:3},s="Encoding and Decoding",p={unversionedId:"json/encoding-and-decoding",id:"json/encoding-and-decoding",title:"Encoding and Decoding",description:"Converting between your domain models and JSON is such a common task when",source:"@site/docs/json/encoding-and-decoding.mdx",sourceDirName:"json",slug:"/json/encoding-and-decoding",permalink:"/ribs/docs/json/encoding-and-decoding",draft:!1,editUrl:"https://github.com/cranst0n/ribs/edit/main/website/docs/json/encoding-and-decoding.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Creating JSON",permalink:"/ribs/docs/json/creating-json"},next:{title:"Streaming",permalink:"/ribs/docs/json/streaming"}},l={},c=[{value:"Decoder",id:"decoder",level:2},{value:"Error handling",id:"error-handling",level:2},{value:"Encoder",id:"encoder",level:2},{value:"Codec",id:"codec",level:2}],m={toc:c},u="wrapper";function h(e){let{components:n,...t}=e;return(0,i.kt)(u,(0,o.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"encoding-and-decoding"},"Encoding and Decoding"),(0,i.kt)("p",null,"Converting between your domain models and JSON is such a common task when\nbuilding useful programs, every language under the sun is saturated with\nlibraries that have their own flavor of filling the developer need. Each\nundoubtedly comes with it's own set of pros and cons. Hopefully this page\nwill convince you that Ribs JSON brings enough utility to be considered\namongst other solutions in the Dart ecosystem."),(0,i.kt)("h2",{id:"decoder"},"Decoder"),(0,i.kt)("p",null,"For most cases, defining a ",(0,i.kt)("inlineCode",{parentName:"p"},"Codec")," for your domain models is where you'll\nfind the most utility from the Ribs JSON library. However, it's worth knowing\nhow ",(0,i.kt)("inlineCode",{parentName:"p"},"Decoder")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Encoder")," work since ",(0,i.kt)("inlineCode",{parentName:"p"},"Codec")," is essentially a composition of\nthose two types."),(0,i.kt)("p",null,"Let's quickly go through a quick scenario to introduce how the API works:"),(0,i.kt)(a.O,{language:"dart",title:"Domain Model",snippet:d,section:"codecs-1",mdxType:"CodeSnippet"}),(0,i.kt)("p",null,"Now that we know what models we need to convert, it's time to create a few ",(0,i.kt)("inlineCode",{parentName:"p"},"Decoder"),"s for\neach type:"),(0,i.kt)(a.O,{language:"dart",title:"Decoders",snippet:d,section:"codecs-2",mdxType:"CodeSnippet"}),(0,i.kt)("p",null,"There's a bit to take in here so we can break it down into a few pieces an analyze them\none at a time:"),(0,i.kt)("p",null,"The first ",(0,i.kt)("inlineCode",{parentName:"p"},"Decoder")," we define is the ",(0,i.kt)("inlineCode",{parentName:"p"},"petTypeDecoder")," which expects to find an\n",(0,i.kt)("inlineCode",{parentName:"p"},"int")," and proceeds to ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," that to the value at ",(0,i.kt)("inlineCode",{parentName:"p"},"PetType.values[n]"),".  ",(0,i.kt)("em",{parentName:"p"},"We'll\nrevisit this particular Decoder later since this implementation isn't entirely\ncorrect.")),(0,i.kt)("p",null,"Next, the ",(0,i.kt)("inlineCode",{parentName:"p"},"petDecoder")," uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"Decoder.product3")," function, which expects 3\n",(0,i.kt)("inlineCode",{parentName:"p"},"Decoders")," that will each handle decoding one value, as well as a function that\nwill decide how those values are combined. In this case, we have:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A decoder that expects to find a string value at the key ",(0,i.kt)("inlineCode",{parentName:"li"},"name"),"."),(0,i.kt)("li",{parentName:"ul"},"A decoder that expects to find an ",(0,i.kt)("em",{parentName:"li"},"optional")," double (or nullable) value at the\nkey ",(0,i.kt)("inlineCode",{parentName:"li"},"weight"),"."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"petTypeDecoder")," we already defined expects to find an int value at the key\n",(0,i.kt)("inlineCode",{parentName:"li"},"type")," which will then be ",(0,i.kt)("inlineCode",{parentName:"li"},"map"),"ped to a ",(0,i.kt)("inlineCode",{parentName:"li"},"PetType"),"."),(0,i.kt)("li",{parentName:"ul"},"A function that declares the 3 values should be combined to create a new\ninstance of ",(0,i.kt)("inlineCode",{parentName:"li"},"User"),".")),(0,i.kt)("p",null,"Since the input is valid in this small example, a new instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Right(User)"),"\nis what we end up with."),(0,i.kt)("h2",{id:"error-handling"},"Error handling"),(0,i.kt)("p",null,"Now let's revist the definition of our ",(0,i.kt)("inlineCode",{parentName:"p"},"petTypeDecoder")," above. It has a fatal\nflaw which we can address using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Decoder")," API. Consider the following\nexample:"),(0,i.kt)(a.O,{language:"dart",title:"Decoder Error",snippet:d,section:"codecs-3",mdxType:"CodeSnippet"}),(0,i.kt)("p",null,"The last call to ",(0,i.kt)("inlineCode",{parentName:"p"},"Json.decode")," throws an exception! This is because the integer\nvalue (100) doesn't correspond to a valid ",(0,i.kt)("inlineCode",{parentName:"p"},"PetType")," enum value. What is to be\ndone? The best first step is to consult the API to see what combinators are\navailble on ",(0,i.kt)("inlineCode",{parentName:"p"},"Decoder")," to handle such scenarios. Here's an improved solution:"),(0,i.kt)(a.O,{language:"dart",title:"Decoder.emap",snippet:d,section:"codecs-4",mdxType:"CodeSnippet"}),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Decoder.emap")," allows you to map a value but provide a function that return\nan ",(0,i.kt)("inlineCode",{parentName:"p"},"Either<String, A>>")," which allows you the developer to determine how\nerrors during decoding should be handled."),(0,i.kt)("p",null,"Finally, encoding and decoding ",(0,i.kt)("inlineCode",{parentName:"p"},"enum"),"s is so common that the API provides a\n",(0,i.kt)("inlineCode",{parentName:"p"},"Decoder"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Encoder")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Codec")," specifically designed for them:"),(0,i.kt)(a.O,{language:"dart",title:"Decoder.enumeration",snippet:d,section:"codecs-enumeration",mdxType:"CodeSnippet"}),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"Decoder.emap")," only scratches the surface of how you can customize a Decoders\nbehavior. Browse the API to see what else is available!")),(0,i.kt)("h2",{id:"encoder"},"Encoder"),(0,i.kt)("p",null,"Next in line is seeing how we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Encoder")," class to convert our domain\nmodels into ",(0,i.kt)("inlineCode",{parentName:"p"},"Json"),". The strategy is similar to the one we took with our decoders.\nbuild one for each data type, and pies them together to build a more elaborate and\ncomplex ",(0,i.kt)("inlineCode",{parentName:"p"},"Encoder"),"."),(0,i.kt)(a.O,{language:"dart",title:"Model Encoders",snippet:d,section:"codecs-5",mdxType:"CodeSnippet"}),(0,i.kt)("h2",{id:"codec"},"Codec"),(0,i.kt)("p",null,"While what we've done so far is effective and composable, an argument can be made that\nit's pretty verbose. We can cut down on that issue quite a bit by combining ",(0,i.kt)("inlineCode",{parentName:"p"},"Decoder"),"s\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"Encoder"),"s in form of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Codec"),"!"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Usually a ",(0,i.kt)("inlineCode",{parentName:"p"},"Codec")," is what you'll want to use when writing your\n(de)serialization code but sometimes you'll want or need a little more control\nwhich is why it's still useful to be familiar with ",(0,i.kt)("inlineCode",{parentName:"p"},"Decoder")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Encoder"),".")),(0,i.kt)("p",null,"Let's use ",(0,i.kt)("inlineCode",{parentName:"p"},"Codec")," to rewrite the previous ",(0,i.kt)("inlineCode",{parentName:"p"},"Decoder")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Encoder"),"'s:"),(0,i.kt)(a.O,{language:"dart",title:"Model Codecs",snippet:d,section:"codecs-6",mdxType:"CodeSnippet"}),(0,i.kt)("p",null,"This example uses the new form of ",(0,i.kt)("inlineCode",{parentName:"p"},'"string".as(Codec.integer)')," which is just\nsyntax equivalent to what we used before in our ",(0,i.kt)("inlineCode",{parentName:"p"},"Encoder")," definitions. The given\n",(0,i.kt)("inlineCode",{parentName:"p"},"Codec")," is used to decode the value at the given key."))}h.isMDXComponent=!0}}]);